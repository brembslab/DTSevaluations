---
title: "*Drosophila* Time Series - Project Evaluation Sheet"
output: 
  html_document:
    number_sections: true
    toc: true
    toc_float: true
    keep_md: FALSE
---
<style type="text/css">
  body .main-container {
    max-width: 1800px !important;
  }
  h1.title {
  font-size: 38px;
  color: DarkRed;
  text-align: center;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, packages, eval=FALSE, echo=FALSE}
# load packages 
library(ggplot2)
library(tidyr)
library(dygraphs)
library(grid)
library(reshape2)
library(dplyr)
library(gridExtra)
library(yaml)
library(ggsignif)
library(effsize)
library(pwr)
library(BayesFactor)
library(genefilter)
library(seewave)
library(lubridate)
library(dabestr)

## source the script with the functions needed for analysis
source("readXMLdatafile.R")
source("DTS_plotfunctions.R")
```

<center><h2>for time series data set: "<b>`r paste(project.data$experiment$title)`</b>"</h2></center>
<center>Rendered on `r format(Sys.time(), '%d %B %Y')`</center>

# Metadata

**Project file (YAML):** `r paste('<a href="../', basename(project.file), '">', project.data$experiment$title, '</a>', sep = "")`  
**Description:** `r paste(project.data$experiment$description)`  
**Measurement RRID:** `r paste('<a href="https://scicrunch.org/resolver/RRID:', project.data$experiment$id, '">', project.data$experiment$id, '</a>', sep = "")`  
**Experimenter:** `r paste(experimenter$firstname, experimenter$lastname, sep = " ")`; **ORCID:** [`r paste(experimenter$orcid)`](http://orcid.org/`r paste(experimenter$orcid)`)  
**Experiment duration:** `r paste(seconds_to_period(as.numeric(as.character(experiment$duration))))`  

# Experimental Design
```{r expdesign, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 3, fig.width = (NofPeriods+1)}
#Write table of period design
periods <- periods[-6,]
periods[3,periods["outcome",]==0]="test"
periods[3,periods["outcome",]==1]="training"
grid.table(periods)
```

```{r Graphdim, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}
if(lengths(project.data["resources"]) == 1){
len = as.integer(5)
} else {
len = as.integer(8)
}
aspect_ratio = 4/nrow(sequence %>% na.omit())


```

# Experimental groups and single fly evaluations

**Number of experimental groups:** `r paste(NofGroups)`
```{r singleflydata, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}
exp_groups <- as.data.frame(t(plyr::ldply(exp_groups, rbind))) #make dataframe from list
colnames(exp_groups) = as.character(unlist(exp_groups[1, ])) # make group names to column names
#tidy the dataframe up a little
exp_groups = exp_groups[-1, ,drop=F] #remove the first row which is now column names, without converting to a vector in case of single column
rownames(exp_groups) <- NULL #remove the numbers
kable(exp_groups) #plot table with links to individual fly evaluations
```

# Histograms
## Fly Behavior Histograms

```{r FlyHistogram, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 12, fig.width = 8, comment=NA, results='asis'}    

for(x in 1:NofGroups)
  {
    cat("<center><h4>",project.data[["resources"]][[x]][["title"]],"</h4></center>")
    flyhistos <- grouped.flyhistos[[x]]
    multiplot(plotlist = flyhistos, cols=round(NofPeriods/5)) #flyhistos
}  
```


```{r PositionHistogram, eval=('fs' %in% sequence$type || 'color' %in% sequence$type), echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 12, fig.width = 8, comment=NA, results='asis'}    
cat("\n## Arena Position Histograms\n")
for(x in 1:NofGroups)
  {
    cat("<center><h4>",project.data[["resources"]][[x]][["title"]],"</h4></center>")
    poshistos <- grouped.poshistos[[x]]
    multiplot(plotlist = Filter(Negate(is.null), poshistos), cols=round(sum(poshistos!="NULL")/5)) #positionhistos
}

```

<!-- Computing optomotor data if they are present -->

```{r om, echo=FALSE}
om <- any(grepl("optomotor", sequence$type)==TRUE) ###determine if there are optomotor periods
```

`r if (om) '# Optomotor Traces'`

```{r Optomotor, eval=om, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 10, comment=NA, results='asis'}
 plotOM=ldply(grouped.OMdata, data.frame)            #move the dataframes for each group into a single dataframe
 plotOM=plotOM[,c("time","means","sd","group")]

 #plot averaged OM traces

  print(ggplot(plotOM, aes(x=time/1000, y=means, group = group)) +
        theme(panel.grid.major.x = element_blank(),panel.grid.major.y = element_line( size=.1, color="grey"))+
        geom_rect(aes(xmin = mean(plotOM$time/1000),xmax = Inf ,ymin = -Inf, ymax = Inf),fill=("grey"), alpha = 0.01)+
        geom_ribbon(aes(ymin=means-sd, ymax=means+sd, fill = group), alpha=0.5) +
        geom_hline(yintercept = 0, color="black") +
        scale_fill_manual(values = boxcolors) +
        geom_line(aes(colour = group), size = 1) + 
        scale_color_manual(values = boxcolors) +
        ggtitle("Mean Optomotor Traces and Standard Deviations") +
        guides(colour = guide_legend(override.aes = list(size=3))) +
        theme_light(base_size = 16) + 
          theme(legend.justification=c(1,0),
            legend.position="right", 
            legend.title=element_blank(), 
            legend.key.size = unit(2, 'lines'),
            legend.key = element_rect(size = 6),
            legend.box.background = element_rect(fill="white"),
            legend.box.margin = margin(4, 4, 4, 4),
            legend.text=element_text(size=14), 
            panel.grid.major.y = element_blank(),
            panel.grid.minor = element_blank(),
            panel.border = element_rect(size = 0.5, linetype = "solid", colour = "black", fill=NA)) +
          theme(axis.text.y = element_text(size=12))+
          ylab("Optomotor Response [rel. units]") + 
          xlab("Time [s]")+
          annotate("text", -Inf, Inf, label = "Right (clockwise) arena rotations", hjust = -0.05, vjust = 1.3)+
          annotate("text", Inf, -Inf, label = "Left (counter-clockwise) arena rotations", hjust =1, vjust = -1.5)+
          theme(panel.grid.major.x = element_blank(),panel.grid.major.y = element_line( size=.1, color="grey"))+
          scale_x_continuous(expand = expand_scale(add = 0)))
          
          

```

`r if (om) '# Optomotor Parameter Analysis'`

```{r statvariables, echo=FALSE}
two <- NofGroups==2     #determine if we need to do between groups tests
    signif = project.data[["statistics"]][["significance-levels"]]                   #get significance levels
    groupnames <- unlist(sapply(project.data[["resources"]], function(x) x["name"])) #get a vector with all group names
    priorval = project.data[["statistics"]][["priors"]]                              #get priors for FPR calculation

```

```{r OMparams, eval=om, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8, comment=NA, results='asis'}

plotOMparams=ldply(grouped.OMparams, data.frame)    #move the dataframes from each group into a single dataframe
samplesizes = as.numeric(table(plotOMparams$group)) #determine sample sizes in each group
OMvariables = head(names(plotOMparams),-1)
OMtitles = c("Optomotor Magnitude", "Rate Constant", "Asymmetry Index")

#for one group without statistics
if(NofGroups==1)
  {
        for (v in 1:3) {
           cat(paste("\n\n## ", OMtitles[v], "\n\n", sep = ""))
           print(ggplot(plotOMparams, aes(group, plotOMparams[[OMvariables[v]]])) +
              geom_boxplot(fill = boxcolors, notch = FALSE, outlier.color=NA, width=0.8, size=0.6) +
              geom_jitter(data = plotOMparams, aes(group, plotOMparams[[OMvariables[v]]]), position=position_jitter(0.3), shape=21, size=3, colour="black", fill="grey50", alpha=0.4) +
              theme_light(base_size = 16) + theme(panel.grid.minor = element_blank(), panel.grid.major.x = element_blank(), panel.border = element_rect(size = 0.5, linetype = "solid", colour = "black", fill=NA)) +
              theme(axis.text.y = element_text(size=18))+ ylab(paste(OMtitles[v], " [rel. units]", sep = ""))+ xlab("Groups")+ theme(aspect.ratio=3/NofGroups)+
              samplesizes.annotate(boxes, samplesizes))
        }
}

#for two groups with statistics
if(two)
  {
        for (v in 1:3) {
           cat(paste("\n\n## ", OMtitles[v], "\n\n", sep = ""))
            utest = signif(wilcox.test(plotOMparams[[OMvariables[v]]] ~ plotOMparams$group)$p.value, 3) #compare the two groups with a U-test and collect p-value
            w.statistic = signif(wilcox.test(plotOMparams[[OMvariables[v]]] ~ plotOMparams$group)$statistic, 3)
            #compute effect size Cohen's D
            cohend = signif(cohen.d(plotOMparams[[OMvariables[v]]] ~ plotOMparams$group)$estimate, 3)
            #calculate statistical power
            alt = project.data[["statistics"]][["two.groups"]][["power"]]
            power=signif(pwr.t2n.test(n1 = samplesizes[1], n2= samplesizes[2], d = cohend, alternative = alt, sig.level = signif[1])$power, 3)
            #calculate Bayes Factor
            bayesF=extractBF(ttestBF(plotOMparams[[OMvariables[v]]][plotOMparams$group==groupnames[1]], plotOMparams[[OMvariables[v]]][plotOMparams$group==groupnames[2]]))
            #calculate FPR for priors set in project file#
            #run first prior  
              prior=priorval[1]
              out=calc.FPR(samplesizes,utest,prior,abs(cohend))  #output=c(FPR,x0,y0,x1,y1)
              fpz1=out[1]
            #run second prior  
              prior=priorval[2]
              out=calc.FPR(samplesizes,utest,prior,abs(cohend))  #output=c(FPR,x0,y0,x1,y1)
              fpz2=out[1]
            #Power and likelihood ratio: NB for two sided test, need 2*y0
              LR=out[5]/(2*out[3])        #lik ratio (Hi1/H0) =y1/2*y0
        
              #make tidy table of results
            results.utest<-data.frame(values=c(signif[1],
                                               w.statistic,
                                               cohend,
                                               power,
                                               signif(bayesF$bf, 3),
                                               signif(bayesF$error, 3),
                                               signif(fpz1, 3),
                                               signif(fpz2, 3),
                                               signif(LR, 3)))
            rownames(results.utest)<-c("Significance level",
                                       "MW U-Test, W",
                                       "Cohen's D",
                                       "stat. Power",
                                       "Bayes Factor",
                                       "Bayes Factor error",
                                       paste("FP risk, prior ",priorval[1]),
                                       paste("FP risk, prior ",priorval[2]),
                                       "Likelihood Ratio")
            
        # plot two PIs with asterisks
          plots.2test<-list(ggplot(plotOMparams, aes(group, plotOMparams[[OMvariables[v]]])) +
              geom_boxplot(fill = boxcolors, notch = TRUE, outlier.color=NA, width=0.8, size=0.6) +
              geom_jitter(data = plotOMparams, aes(group, plotOMparams[[OMvariables[v]]]), position=position_jitter(0.3), shape=21, size=3, colour="black", fill="grey50", alpha=0.4) +
              ggtitle(paste("U-Test, p=", utest)) +
              theme_light(base_size = 16) + theme(panel.grid.minor = element_blank(), panel.grid.major.x = element_blank(), panel.border = element_rect(size = 0.5, linetype = "solid", colour = "black", fill=NA)) +
              theme(axis.text.y = element_text(size=18))+ ylab(paste(OMtitles[v], " [rel. units]", sep = ""))+ xlab("Groups")+ theme(aspect.ratio=3/NofGroups)+
              geom_signif(comparisons = list(c(groupnames)), map_signif_level= c("***"= signif[3],"**"= signif[2], "*"= signif[1]), textsize=8, vjust=0.5) +
              samplesizes.annotate(boxes, samplesizes))
        
          #add table with results and plot
          plots.2test[[2]]<-tableGrob(results.utest)
          grid.arrange(grobs = plots.2test, ncol=2)
        } #for 
}


```


# Fourier Spectrum Analysis

```{r spectra, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8}
spectemp <- do.call("rbind", grouped.spectra) #create single data.frame with grouping variable from list of groups
print(ggplot(spectemp, aes(x=freq, y=mean, group = group)) + 
        geom_ribbon(aes(ymin=mean-sd, ymax=mean+sd, fill = group), alpha=0.5) +
        scale_fill_manual(values = boxcolors) +
        geom_line(aes(colour = group), size = 2) + 
        scale_color_manual(values = boxcolors) +
        scale_x_continuous(breaks = seq(0, 10, 2), limits = c(0, 10), expand=c(0,0)) +
        scale_y_continuous(breaks = seq(0, 1, 0.2), limits = c(0, 1), expand=c(0,0)) +
        ggtitle("Powerspectra") +
        guides(colour = guide_legend(override.aes = list(size=3))) +
        theme_light(base_size = 16) + theme(legend.justification=c(1,0),
                                            legend.position=c(0.94,0.60), 
                                            legend.title=element_blank(), 
                                            legend.key.size = unit(2, 'lines'),
                                            legend.key = element_rect(size = 6),
                                            legend.box.background = element_rect(fill="white"),
                                            legend.box.margin = margin(4, 4, 4, 4),
                                            legend.text=element_text(size=14), 
                                            panel.grid.major.y = element_blank(),
                                            panel.grid.minor = element_blank(),
                                            panel.border = element_rect(size = 0.5, linetype = "solid", colour = "black", fill=NA)) +
        theme(axis.text.y = element_text(size=12))+ ylab("mean rel. Power") + xlab("Frequency [Hz]"))
```


```{r PIpresent, echo=FALSE}
PIs <- !all(is.na(sequence$lambda)) ###determine if there are any PIs to be plotted
```


```{r PIbar, eval=PIs, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = len, fig.width = 8, comment=NA, results='asis'}
cat("\n# Performance Indices\n \n## Performance Index bar plot with SEM:\n")

PIplots <- list()
for(x in 1:NofGroups)
  {
    PIprofile <- grouped.PIprofiles[[x]]
    PIprofile <- PIprofile[colSums(!is.na(PIprofile)) > 0] #remove empty columns
    
      # compute summary statistics
      error <- data.frame(period=integer(ncol(PIprofile)), mean=numeric(ncol(PIprofile)), sem=numeric(ncol(PIprofile)))
      for(e in 1:ncol(PIprofile))
      {
        error$period[e]=e
        error$mean[e]=mean(PIprofile[,e])
        error$sem[e]=sd(PIprofile[,e]/sqrt(nrow(PIprofile)))
      }
      # plot graph
     PIplots[[x]] <- ggplot(error, aes(x=period, y=mean)) + 
              geom_hline(yintercept = 0, colour = "#887000", size = 1.2) +
              geom_bar(fill = as.vector(na.omit(sequence$color)), position=position_dodge(), stat="identity", colour="black") +
              geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem),
                            width=0,
                            size=1.5,
                            position=position_dodge(.9)) +
              ggtitle(paste(project.data[["resources"]][[x]][["title"]], ", N=",nrow(PIprofile))) +
              scale_x_continuous(breaks = seq(1, NofPeriods, 1)) +
              scale_y_continuous(breaks = seq(-1, 1, .2)) +
              theme_light(base_size = 16) + 
              theme(panel.grid.major.x = element_blank(),panel.grid.minor = element_blank(), panel.border = element_rect(size = 0.5, linetype = "solid", colour = "black", fill=NA)) +
              theme(axis.text.y = element_text(size=18))+ 
              ylab("PI [rel. units]") + 
              theme(aspect.ratio=aspect_ratio)
  }
grid.arrange(grobs = PIplots, nrow=NofGroups)
```


```{r BoxWithNotch, eval=PIs, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = len, fig.width = 8, comment=NA, results='asis'}
cat("\n## Performance Index box&dotplot with notches:\n")

for(x in 1:NofGroups)
  {
  PIprofile <- grouped.PIprofiles[[x]]
  PIprofile <- PIprofile[colSums(!is.na(PIprofile)) > 0] #remove empty columns
  PIcombined <- grouped.PIcombined[[x]]
  PIcombined <- PIcombined[colSums(!is.na(PIcombined)) > 0]
  PIcombined["new"] <- NA #issues with melting this df so creating a new column for this reason
  PIcombined = melt(PIcombined,id.vars="new") #melt data frames 
   melted = melt(PIprofile)
   melted["color"] <- PIcombined$value
    PIplots[[x]] <- ggplot(melt(PIprofile), aes(variable, value)) +
              geom_hline(yintercept = 0, colour = "#887000", size = 1.2) +
              geom_boxplot(fill = as.vector(na.omit(sequence$color)), notch = TRUE, outlier.color=NA, width=0.8, size=0.6) +
              ggtitle(paste(project.data[["resources"]][[x]][["title"]], ", N=",nrow(PIprofile))) +
              scale_y_continuous(breaks = seq(-1, 1, .4)) +
              theme_light(base_size = 16) + 
              theme(panel.grid.minor = element_blank(), panel.grid.major.x = element_blank() ,panel.border = element_rect(size = 0.5, linetype = "solid", colour = "black", fill=NA)) +
              theme(axis.text.y = element_text(size=18))+ 
              ylab("PI [rel. units]")+ 
              xlab("Experiment Sequence") + 
              theme(aspect.ratio=0.8*aspect_ratio) +
              scale_fill_discrete(name = "Punishment") #changes the title of the legend. Can be set to anything but in this case I went with "Punishment" 
if(any(grepl("yt| fs | color", sequence$type)==TRUE))
{
  PIplots[[x]] = PIplots[[x]] + geom_jitter(data = melted, aes(x=variable, y=value, fill=color), position=position_jitter(0.3), shape=21, size=3, colour="black")
} else {
  PIplots[[x]] = PIplots[[x]] + geom_jitter(data = melt(PIprofile), aes(variable, value), position=position_jitter(0.3), shape=21, size=3, colour="black", fill="grey50", alpha=0.4)
}
    }  
grid.arrange(grobs = PIplots, nrow=NofGroups)
```


```{r BoxNoNotch, eval=PIs, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = len, fig.width = 8, comment=NA, results='asis'}
cat("\n## Performance Index box&dotplot without notches:\n")

for(x in 1:NofGroups)
  {
  PIprofile <- grouped.PIprofiles[[x]]
  PIprofile <- PIprofile[colSums(!is.na(PIprofile)) > 0] #remove empty columns
  PIcombined <- grouped.PIcombined[[x]]
  PIcombined <- PIcombined[colSums(!is.na(PIcombined)) > 0]
  PIcombined["new"] <- NA #issues with melting this df so creating a new column for this reason
  PIcombined = melt(PIcombined,id.vars="new") #melt data frames 
   melted = melt(PIprofile)
   melted["color"] <- PIcombined$value
    PIplots[[x]] <- ggplot(melt(PIprofile), aes(variable, value)) +
              geom_hline(yintercept = 0, colour = "#887000", size = 1.2) +
              geom_boxplot(fill = as.vector(na.omit(sequence$color)), notch = FALSE, outlier.color=NA, width=0.8, size=0.6) +
              ggtitle(paste(project.data[["resources"]][[x]][["title"]], ", N=",nrow(PIprofile))) +
              scale_y_continuous(breaks = seq(-1, 1, .4)) +
              theme_light(base_size = 16) + 
              theme(panel.grid.minor = element_blank(), panel.grid.major.x = element_blank() ,panel.border = element_rect(size = 0.5, linetype = "solid", colour = "black", fill=NA)) +
              theme(axis.text.y = element_text(size=18))+ 
              ylab("PI [rel. units]")+ xlab("Experiment Sequence") + 
              theme(aspect.ratio=aspect_ratio)
if(any(grepl("yt| fs | color", sequence$type)==TRUE))
{
  PIplots[[x]] = PIplots[[x]] + geom_jitter(data = melted, aes(x=variable, y=value, fill=color), position=position_jitter(0.3), shape=21, size=3, colour="black")
} else {
  PIplots[[x]] = PIplots[[x]] + geom_jitter(data = melt(PIprofile), aes(variable, value), position=position_jitter(0.3), shape=21, size=3, colour="black", fill="grey50", alpha=0.4)
}
    }        
grid.arrange(grobs = PIplots, nrow=NofGroups)
```


```{r Violin, eval=PIs, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = len, fig.width = 8, comment=NA, results='asis'}
cat("\n## Performance Index Violin Plot:\n")

for(x in 1:NofGroups)
  {
  PIprofile <- grouped.PIprofiles[[x]]
  PIprofile <- PIprofile[colSums(!is.na(PIprofile)) > 0] #remove empty columns
  
    PIplots[[x]] <- ggplot(melt(PIprofile), aes(variable, value)) +
              geom_hline(yintercept = 0, colour = "#887000", size = 1.2) +
              geom_violin(width = 1.1) +
              geom_boxplot(fill = as.vector(na.omit(sequence$color)), width = 0.1, outlier.color="darkred") +
              ggtitle(paste(project.data[["resources"]][[x]][["title"]], ", N=",nrow(PIprofile))) +
              scale_y_continuous(breaks = seq(-1, 1, .4)) +
              theme_light(base_size = 16) + 
              theme(panel.grid.minor = element_blank(), panel.grid.major.x = element_blank() ,panel.border = element_rect(size = 0.5, linetype = "solid", colour = "black", fill=NA)) +
              theme(axis.text.y = element_text(size=18))+ 
              ylab("PI [rel. units]")+ 
              xlab("Experiment Sequence") + 
              theme(aspect.ratio=aspect_ratio)
  }
grid.arrange(grobs = PIplots, nrow=NofGroups)
```


```{r StatSetup, echo=FALSE}
twogroupstats <- project.data[["statistics"]][["two.groups"]][["data"]]==1      #etermine if statistics for two groups are required
wil <- project.data[["statistics"]][["single.groups"]][["data"]]==1             #determine if we need to do single tests
learningscore = project.data[["statistics"]][["learning-score"]][["data"]]        #get the PI that is going to be tested

#create new dataframe with only the chosen PI values
if(PIs){
PIstat <- list()
for(x in 1:NofGroups){PIstat[[x]] <- grouped.PIprofiles[[x]][[learningscore]]}
PIstat <- as.data.frame(t(plyr::ldply(PIstat, rbind)))                          #convert PI list to data.frame
colnames(PIstat) <- unlist(sapply(project.data[["resources"]], '[', 'name'))    #add group names as column names to PIstat
#compute standard deviations
SDs<-as.numeric(apply(PIstat, 2, function(x) sd(na.omit(x))))
if(!om){samplesizes<-as.numeric(apply(PIstat, 2, function(x) length(na.omit(x))))}
}
```


```{r Wilcoxon, eval=wil, echo=FALSE, error=FALSE, message=FALSE, warning=FALSE, fig.align = "center", fig.height = 6, fig.width = 8, comment=NA, results='asis'}
cat("\n# Learning Score Statistics\n## Statistical tests of single groups against zero\n")
  # grouped.color = melt(grouped.color)
  # if(!exists("PIstatmelt")){PIstatmelt <- list()}
  # PIstatmelt = melt(PIstat)
  # PIstatmelt["color"]= grouped.color$value 
  wilcoxon<-numeric()  
  for(x in 1:NofGroups){wilcoxon[x] = signif(wilcox.test(PIstat[[x]])$p.value, 3)} #test all groups against zero
  #compute Bayes Factor for single group 
  if(NofGroups==1){
    results.bayes=extractBF(ttestBF(na.omit(PIstat[[1]])))
    results.bayes <- results.bayes[-c(3,4)] # drop the date and code columns
    row.names(results.bayes) <- groupnames #group name as row name
    results.bayes <- signif(results.bayes, digits=3) # reduce results to 3 significant digits
    } else { #compute Bayes Factors for several groups
          results.bayes<-list()
          for(x in 1:NofGroups){results.bayes[[x]]=extractBF(ttestBF(na.omit(PIstat[[x]])))} #extract BayesFactors for all groups
          results.bayes<-do.call("rbind", results.bayes) #fuse all Bayes results into one dataframe
          results.bayes <- results.bayes[-c(3,4)]# drop the date and code columns
          row.names(results.bayes) <- groupnames #group name as row name
          results.bayes <- signif(results.bayes, digits=3) # reduce results to 3 significant digits
    }
# plot PI box plot test against zero
  plots.singles<-list(ggplot(melt(PIstat), aes(variable, value)) +
    geom_hline(yintercept = 0, colour = "#887000", size = 1.2) +
    geom_boxplot(fill = boxcolors, notch = FALSE, outlier.color=NA, width=0.8, size=0.6) +
    ggtitle("Wilcoxon") +
    scale_y_continuous(breaks = seq(-1, 1, .2)) +
    theme_light(base_size = 16) + theme(panel.grid.minor = element_blank(), panel.grid.major.x = element_blank() ,panel.border = element_rect(size = 0.5, linetype = "solid", colour = "black", fill=NA)) +
    theme(axis.text.y = element_text(size=18))+ ylab(paste("PI", learningscore, " [rel. units]", sep = ""))+ xlab("Groups")+ theme(aspect.ratio=3/NofGroups)+
    samplesizes.annotate(boxes, samplesizes) +
    wilcox.annotate(boxes, wilcoxon))
  
if(any(grepl("yt| fs | color", sequence$type)==TRUE)){
  plots.singles[[1]] = plots.singles[[1]] + geom_jitter(data = PIstatmelt, aes(x=variable, y=value, fill=color), position=position_jitter(0.3), shape=21, size=3, colour="black") + theme(
  legend.position = c(1.6, 1.00), legend.justification = c("right", "top")) + guides(fill=guide_legend(title="Punished side"))
} else {
  plots.singles = plots.singles + geom_jitter(data = melt(PIstat), aes(variable, value), position=position_jitter(0.3), shape=21, size=3, colour="black", fill="grey50", alpha=0.4)
}
  
#add table with results and plot
    plots.singles[[2]]<-tableGrob(results.bayes)
    grid.arrange(grobs = plots.singles, ncol=2)
```

```{r Utest, eval=twogroupstats, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8, comment=NA, results='asis'}
cat("\n## Statistical tests between two groups\n")

    utest = signif(wilcox.test(PIstat[[1]],PIstat[[2]])$p.value, 3) #compare the two groups with a U-test and collect p-value
    w.statistic = signif(wilcox.test(PIstat[[1]],PIstat[[2]])$statistic, 3)
    #compute effect size Cohen's D
    cohend = signif(cohen.d(na.omit(PIstat[,1]), na.omit(PIstat[,2]))$estimate, 3)
    #calculate statistical power
    alt = project.data[["statistics"]][["two.groups"]][["power"]]
    power=signif(pwr.t2n.test(n1 = samplesizes[1], n2= samplesizes[2], d = cohend, alternative = alt, sig.level = signif[1])$power, 3)
    #calculate Bayes Factor
    bayesF=extractBF(ttestBF(na.omit(PIstat[[1]]), na.omit(PIstat[[2]])))
    #calculate FPR for priors set in project file#
    #run first prior  
      prior=priorval[1]
      out=calc.FPR(samplesizes,utest,prior,abs(cohend))  #output=c(FPR,x0,y0,x1,y1)
      fpz1=out[1]
    #run second prior  
      prior=priorval[2]
      out=calc.FPR(samplesizes,utest,prior,abs(cohend))  #output=c(FPR,x0,y0,x1,y1)
      fpz2=out[1]
    #Power and likelihood ratio: NB for two sided test, need 2*y0
      LR=out[5]/(2*out[3])        #lik ratio (Hi1/H0) =y1/2*y0

      #make tidy table of results
    results.utest<-data.frame(values=c(signif[1],
                                       w.statistic,
                                       cohend,
                                       power,
                                       signif(bayesF$bf, 3),
                                       signif(bayesF$error, 3),
                                       signif(fpz1, 3),
                                       signif(fpz2, 3),
                                       signif(LR, 3)))
    rownames(results.utest)<-c("Significance level",
                               "MW U-Test, W",
                               "Cohen's D",
                               "stat. Power",
                               "Bayes Factor",
                               "Bayes Factor error",
                               paste("FP risk, prior ",priorval[1]),
                               paste("FP risk, prior ",priorval[2]),
                               "Likelihood Ratio")
    
# plot two PIs with asterisks
  plots.2test<-list(ggplot(melt(PIstat), aes(variable, value)) +
      geom_hline(yintercept = 0, colour = "#887000", size = 1.2) +
      geom_boxplot(fill = boxcolors, notch = TRUE, outlier.color=NA, width=0.8, size=0.6) +
      ggtitle(paste("U-Test, p=", utest)) +
      scale_y_continuous(breaks = seq(-1, 1, .2)) +
      theme_light(base_size = 16) + theme(panel.grid.minor = element_blank(), panel.grid.major.x = element_blank(), panel.border = element_rect(size = 0.5, linetype = "solid", colour = "black", fill=NA)) +
      theme(axis.text.y = element_text(size=18))+ ylab(paste("PI", learningscore, " [rel. units]", sep = ""))+ xlab("Groups")+ theme(aspect.ratio=3/NofGroups)+
      geom_signif(comparisons = list(c(colnames(PIstat[1]), colnames(PIstat[2]))), 
                  map_signif_level= c("***"= signif[3],"**"= signif[2], "*"= signif[1]),
                  textsize=8, vjust=0.5) +
      samplesizes.annotate(boxes, samplesizes))
  
if(any(grepl("yt| fs | color", sequence$type)==TRUE)){
  plots.2test[[1]] = plots.2test[[1]] + geom_jitter(data = PIstatmelt, aes(x=variable, y=value, fill=color), position=position_jitter(0.3), shape=21, size=3, colour="black") + theme(
    legend.position = c(1.6, 1.05), legend.justification = c("right", "top")) + guides(fill=guide_legend(title="Punished side"))
} else {
  plots.2test = plots.2test + geom_jitter(data = melt(PIstat), aes(variable, value), position=position_jitter(0.3), shape=21, size=3, colour="black", fill="grey50", alpha=0.4)
}

  #add table with results and plot
  plots.2test[[2]]<-tableGrob(results.utest)
  grid.arrange(grobs = plots.2test, ncol=2)

```

```{r estimationstats, eval=twogroupstats, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8, comment=NA, results='asis'}
cat("\n## Estimation statistics\n")

PIest=na.omit(melt(PIstat)) #create a dataframe that fits estimation stat requirements and remove missing PIs
unpaired_median_diff <- dabest(PIest, variable, value, idx = groupnames, paired = FALSE, func = median) #create estimation results list
print(plot(unpaired_median_diff)) #plot results

```

```{r splitviolins, eval=twogroupstats, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8, comment=NA, results='asis'}
cat("\n## Split Violin Plot\n")

PIest$learningscore=project.data$statistics$`learning-score`$title #reuse estimation stat dataframe and add x-axis value for split violin plots
print(ggplot(PIest, aes(learningscore, value, fill = variable)) + scale_fill_manual(values=boxcolors) + geom_split_violin()) #plot spit violin plot

```