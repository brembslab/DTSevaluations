q()
install.packages(c("adehabitat","XML","lattice","hexbin",
"colorRamps" ,"corrplot","gplots", "rgl", "MASS", "adehabitatLT","corrplot"), dependencies=TRUE)
q()
load("F:/PV-Anlage/.RData")
flyData <- xmlParse(file.choose())
require("XML")
require("data.table")
install.packages(XML)
install.packages("XML")
install.packages("data.table")
library("XML")
flyData <- xmlParse(file.choose())
project.file <- file.choose()
devtools::install_github("ACCLAB/dabestr")
install.packages(devtools)
install.packages("devtools")
devtools::install_github("ACCLAB/dabestr")
devtools::install_github("ACCLAB/dabestr")
install.packages("dabestr")
install.packages(c("assertthat", "backports", "BayesFactor", "BH", "bit", "cli", "cluster", "coda", "colorspace", "cowplot", "DBI", "digest", "dplyr", "dygraphs", "effsize", "evaluate", "ggplot2", "ggpubr", "ggsignif", "glue", "gtable", "gtools", "highr", "htmlwidgets", "jsonlite", "knitr", "lazyeval", "lubridate", "markdown", "MASS", "Matrix", "mgcv", "mime", "munsell", "mvtnorm", "nlme", "pbapply", "pillar", "pkgconfig", "purrr", "R6", "Rcpp", "RcppEigen", "RCurl", "rlang", "rmarkdown", "rpart", "RSQLite", "scales", "seewave", "stringi", "stringr", "survival", "tibble", "tidyr", "tidyselect", "tuneR", "utf8", "XML", "xtable", "xts", "yaml", "zoo"))
install.packages(c("nlme", "rpart"))
install.packages(c("nlme", "rpart"))
devtools::install_github("ACCLAB/dabestr")
install.packages("processx")
devtools::install_github("ACCLAB/dabestr")
install.packages("ps")
devtools::install_github("ACCLAB/dabestr")
install.packages("pkgload")
install.packages("dabestr")
devtools::install_github("ACCLAB/dabestr")
install.packages("fs")
devtools::install_github("ACCLAB/dabestr")
install.packages("plyr")
devtools::install_github("ACCLAB/dabestr")
install.packages("datasets")
install.packages("datasets")
install.packages("datasets")
install.packages("datasets")
install.packages("datasets")
install.packages("datasets")
devtools::install_github("ACCLAB/dabestr")
load("D:/data/course_tlearn/evaluations/.RData")
View(rawdata)
View(rawdata)
View(rawdata)
rawdata$a_pos = rawdata$a_pos-1800
View(rawdata)
View(rawdata)
View(rawdata)
View(experiment)
binsize = as.integer(experiment$sample_rate/20)
real_sample_rate = nrow(rawdata)/(rawdata$time[nrow(rawdata)]/1000)
experiment$sample_rate = real_sample_rate/binsize
View(experiment)
seq(1,length(rawdata$time),binsize)
abs(max(rawdata$period[1002:1005]) - min(rawdata$period[1002:1005]))
abs(max(rawdata$period[1000:2000]) - min(rawdata$period[1000:2000]))
abs(max(rawdata$period[5000:7000]) - min(rawdata$period[5000:7000]))
dumydata = rawdata$period[5000:7000]
table(dummydata)
table(dumydata)
dumydata$1
view(dumydata)
View(dumydata)
ntestnumber=table(dumydata)$1
testnumber=table(dumydata)[1,1]
testnumber=table(dumydata)[1,1]
testtable<-table(dumydata)
testtable
testtable$1
testtable[1.1]
testtable[1.1]>testtable[1.2]
testtable[1.2]
testtable[1.1]
testtable[2.1]
testtable[2]
testtable[1]
testtable[1]>testtable[2]
testtable[2]>testtable[1]
table(dumydata)[1]>table(dumydata)[2]
table(dumydata)[2]>table(dumydata)[1]
View(experiment)
# create the vectors in which to save the downsampled data
timeDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$time)/binsize))
a_posDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$a_pos)/binsize))
torqueDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$torque)/binsize))
periodDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$period)/binsize))
# downsampling time
for (index in seq(1,length(rawdata$time),binsize)) {
if(index < (length(rawdata$time)-binsize)) { # check whether we reached the end of the data; if not:
timeDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$time[index:(index+binsize-1)])/binsize)  # average all data in the bin and save it in the right slot of the downsampled vector
} else {  # in case we reached the end
timeDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$time[index:length(rawdata$time)])/length(rawdata$time[index:length(rawdata$time)])) # average over the remaining values and save the result
}
}
# downsampling position
for (index in seq(1,length(rawdata$a_pos),binsize)) {
if(index < (length(rawdata$a_pos)-binsize)) { # check whether we reached the end of the data; if not:
a_posDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$a_pos[index:(index+binsize-1)])/binsize)  # average all data in the bin and save it in the right slot of the downsampled vector
} else {  # in case we reached the end
a_posDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$a_pos[index:length(rawdata$a_pos)])/length(rawdata$a_pos[index:length(rawdata$a_pos)])) # average over the remaining values and save the result
}
}
# downsampling torque
for (index in seq(1,length(rawdata$torque),binsize)) {
if(index < (length(rawdata$torque)-binsize)) { # check whether we reached the end of the data; if not:
torqueDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$torque[index:(index+binsize-1)])/binsize)  # average all data in the bin and save it in the right slot of the downsampled vector
} else {  # in case we reached the end
torqueDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$torque[index:length(rawdata$torque)])/length(rawdata$torque[index:length(rawdata$torque)])) # average over the remaining values and save the result
}
}
# downsampling period
for (index in seq(1,length(rawdata$period),binsize)) {
if (abs(max(rawdata$period[index:(index+binsize-1)]) - min(rawdata$period[index:(index+binsize-1)])) = 0){ #check if there is a period switch in the bin, if there is:
periodDownsampled[((index-1)/binsize)+1] <- rawdata$period[index]
}
else #if there are two different period values in the bin
{
if (table(rawdata$period[index:(index+binsize-1)])[1]>table(rawdata$period[index:(index+binsize-1)])[2]) #if the majority of values indicates old period
{
periodDownsampled[((index-1)/binsize)+1] <- rawdata$period[index] #make the period vale that of the old period
}
else {periodDownsampled[((index-1)/binsize)+1] <- rawdata$period[index+binsize-1] #if the majority of values indicates new period, set the value to the new period
}
}
}
# bind the downsampled vectors into one dataframe
rawdataDown <- data.frame("time" = timeDownsampled, "a_pos" = a_posDownsampled, "torque" = torqueDownsampled, "period" = periodDownsampled)
# create the vectors in which to save the downsampled data
timeDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$time)/binsize))
a_posDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$a_pos)/binsize))
torqueDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$torque)/binsize))
periodDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$period)/binsize))
# downsampling time
for (index in seq(1,length(rawdata$time),binsize)) {
if(index < (length(rawdata$time)-binsize)) { # check whether we reached the end of the data; if not:
timeDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$time[index:(index+binsize-1)])/binsize)  # average all data in the bin and save it in the right slot of the downsampled vector
} else {  # in case we reached the end
timeDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$time[index:length(rawdata$time)])/length(rawdata$time[index:length(rawdata$time)])) # average over the remaining values and save the result
}
}
# downsampling position
for (index in seq(1,length(rawdata$a_pos),binsize)) {
if(index < (length(rawdata$a_pos)-binsize)) { # check whether we reached the end of the data; if not:
a_posDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$a_pos[index:(index+binsize-1)])/binsize)  # average all data in the bin and save it in the right slot of the downsampled vector
} else {  # in case we reached the end
a_posDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$a_pos[index:length(rawdata$a_pos)])/length(rawdata$a_pos[index:length(rawdata$a_pos)])) # average over the remaining values and save the result
}
}
# downsampling torque
for (index in seq(1,length(rawdata$torque),binsize)) {
if(index < (length(rawdata$torque)-binsize)) { # check whether we reached the end of the data; if not:
torqueDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$torque[index:(index+binsize-1)])/binsize)  # average all data in the bin and save it in the right slot of the downsampled vector
} else {  # in case we reached the end
torqueDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$torque[index:length(rawdata$torque)])/length(rawdata$torque[index:length(rawdata$torque)])) # average over the remaining values and save the result
}
}
# downsampling period
for (index in seq(1,length(rawdata$period),binsize)) {
if (abs(max(rawdata$period[index:(index+binsize-1)]) - min(rawdata$period[index:(index+binsize-1)])) == 0){ #check if there is a period switch in the bin, if there is:
periodDownsampled[((index-1)/binsize)+1] <- rawdata$period[index]
} else { #if, instead, there are two different period values in the bin...
if (table(rawdata$period[index:(index+binsize-1)])[1]>table(rawdata$period[index:(index+binsize-1)])[2]) #if the majority of values indicates old period
{
periodDownsampled[((index-1)/binsize)+1] <- rawdata$period[index] #make the period vale that of the old period
} else {
periodDownsampled[((index-1)/binsize)+1] <- rawdata$period[index+binsize-1] #if the majority of values indicates new period, set the value to the new period
}
}
}
# bind the downsampled vectors into one dataframe
rawdataDown <- data.frame("time" = timeDownsampled, "a_pos" = a_posDownsampled, "torque" = torqueDownsampled, "period" = periodDownsampled)
View(rawdataDown)
View(rawdataDown)
# create the vectors in which to save the downsampled data
timeDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$time)/binsize))
a_posDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$a_pos)/binsize))
torqueDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$torque)/binsize))
periodDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$period)/binsize))
# downsampling time
for (index in seq(1,length(rawdata$time),binsize)) {
if(index < (length(rawdata$time)-binsize)) { # check whether we reached the end of the data; if not:
timeDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$time[index:(index+binsize-1)])/binsize)  # average all data in the bin and save it in the right slot of the downsampled vector
} else {  # in case we reached the end
timeDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$time[index:length(rawdata$time)])/length(rawdata$time[index:length(rawdata$time)])) # average over the remaining values and save the result
}
}
# downsampling position
for (index in seq(1,length(rawdata$a_pos),binsize)) {
if(index < (length(rawdata$a_pos)-binsize)) { # check whether we reached the end of the data; if not:
a_posDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$a_pos[index:(index+binsize-1)])/binsize)  # average all data in the bin and save it in the right slot of the downsampled vector
} else {  # in case we reached the end
a_posDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$a_pos[index:length(rawdata$a_pos)])/length(rawdata$a_pos[index:length(rawdata$a_pos)])) # average over the remaining values and save the result
}
}
# downsampling torque
for (index in seq(1,length(rawdata$torque),binsize)) {
if(index < (length(rawdata$torque)-binsize)) { # check whether we reached the end of the data; if not:
torqueDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$torque[index:(index+binsize-1)])/binsize)  # average all data in the bin and save it in the right slot of the downsampled vector
} else {  # in case we reached the end
torqueDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$torque[index:length(rawdata$torque)])/length(rawdata$torque[index:length(rawdata$torque)])) # average over the remaining values and save the result
}
}
# downsampling period
for (index in seq(1,length(rawdata$period),binsize)) {
if (abs(max(rawdata$period[index:(index+binsize-1)]) - min(rawdata$period[index:(index+binsize-1)])) == 0){ #check if there is a period switch in the bin, if there is:
periodDownsampled[((index-1)/binsize)+1] <- rawdata$period[index]
} else if (table(rawdata$period[index:(index+binsize-1)])[1]>table(rawdata$period[index:(index+binsize-1)])[2]) #if the majority of values indicates old period
{
periodDownsampled[((index-1)/binsize)+1] <- rawdata$period[index] #make the period vale that of the old period
} else {
periodDownsampled[((index-1)/binsize)+1] <- rawdata$period[index+binsize-1] #if the majority of values indicates new period, set the value to the new period
}
}
# bind the downsampled vectors into one dataframe
rawdataDown <- data.frame("time" = timeDownsampled, "a_pos" = a_posDownsampled, "torque" = torqueDownsampled, "period" = periodDownsampled)
length(rawdata$torque)
rawdata$period[length(rawdata$period))
rawdata$period[length(rawdata$period)]
# create the vectors in which to save the downsampled data
timeDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$time)/binsize))
a_posDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$a_pos)/binsize))
torqueDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$torque)/binsize))
periodDownsampled <- vector(mode = "numeric", length = ceiling(length(rawdata$period)/binsize))
# downsampling time
for (index in seq(1,length(rawdata$time),binsize)) {
if(index < (length(rawdata$time)-binsize)) { # check whether we reached the end of the data; if not:
timeDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$time[index:(index+binsize-1)])/binsize)  # average all data in the bin and save it in the right slot of the downsampled vector
} else {  # in case we reached the end
timeDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$time[index:length(rawdata$time)])/length(rawdata$time[index:length(rawdata$time)])) # average over the remaining values and save the result
}
}
# downsampling position
for (index in seq(1,length(rawdata$a_pos),binsize)) {
if(index < (length(rawdata$a_pos)-binsize)) { # check whether we reached the end of the data; if not:
a_posDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$a_pos[index:(index+binsize-1)])/binsize)  # average all data in the bin and save it in the right slot of the downsampled vector
} else {  # in case we reached the end
a_posDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$a_pos[index:length(rawdata$a_pos)])/length(rawdata$a_pos[index:length(rawdata$a_pos)])) # average over the remaining values and save the result
}
}
# downsampling torque
for (index in seq(1,length(rawdata$torque),binsize)) {
if(index < (length(rawdata$torque)-binsize)) { # check whether we reached the end of the data; if not:
torqueDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$torque[index:(index+binsize-1)])/binsize)  # average all data in the bin and save it in the right slot of the downsampled vector
} else {  # in case we reached the end
torqueDownsampled[((index-1)/binsize)+1] <- round(sum(rawdata$torque[index:length(rawdata$torque)])/length(rawdata$torque[index:length(rawdata$torque)])) # average over the remaining values and save the result
}
}
# downsampling period
for (index in seq(1,length(rawdata$period),binsize)) {
if(index < (length(rawdata$period)-binsize)) { # check whether we reached the end of the data; if not:
if (abs(max(rawdata$period[index:(index+binsize-1)]) - min(rawdata$period[index:(index+binsize-1)])) == 0){ #check if there is a period switch in the bin, if there is:
periodDownsampled[((index-1)/binsize)+1] <- rawdata$period[index]
} else if (table(rawdata$period[index:(index+binsize-1)])[1]>table(rawdata$period[index:(index+binsize-1)])[2]) #if the majority of values indicates old period
{
periodDownsampled[((index-1)/binsize)+1] <- rawdata$period[index] #make the period vale that of the old period
} else {
periodDownsampled[((index-1)/binsize)+1] <- rawdata$period[index+binsize-1] #if the majority of values indicates new period, set the value to the new period
}
} else { # in case we reached the end
periodDownsampled[((index-1)/binsize)+1] <- rawdata$period[length(rawdata$period)]
}
}
# bind the downsampled vectors into one dataframe
rawdataDown <- data.frame("time" = timeDownsampled, "a_pos" = a_posDownsampled, "torque" = torqueDownsampled, "period" = periodDownsampled)
View(rawdataDown)
table(rawdata$period)
table(rawdataDown$period)
timeownsampled <- timeDownsampled-timeDownsampled[1]
timeDownsampled <- timeDownsampled-timeDownsampled[1]
rawdataDown <- data.frame("time" = timeDownsampled, "a_pos" = a_posDownsampled, "torque" = torqueDownsampled, "period" = periodDownsampled)
View(rawdataDown)
rawdata$diff <- diff(rawdata$time, 1, 1)
difference <- diff(rawdata$time, 1, 1)
view(difference)
View(difference)
plot(difference)
ggplot(difference)
library(ggplot2)
ggplot(difference)
ggplot(as.data.frame(difference))
lines(difference)
lines(difference)#
lines(difference)#
lines(difference)
plot.new#
plot.new
lines(difference)
plot(difference)
View(rawdata)
real_sample_rate
range=vector(min=sapply(rawdata$torque,min),max=sapply(rawdata$torque,max))
range=data.frame(min=sapply(rawdata$torque,min),max=sapply(rawdata$torque,max))
View(range)
rawdata$torque,min
load("D:/data/DTS_test/colorlearning/.RData")
if (exists(project.data["type"])){ExpType = project.data["type"]} else ExpType = "torquemeter"
project.data["resources"]
exists(project.data["resources"])
exists("project.data["resources"]")
resources %in% project.data
"resources" %in% project.data
"name" %in% project.data
"title" %in% project.data
"Brembs" %in% project.data
View(project.data)
View(project.data)
is.null(project.data["resources"])
is.null(project.data["type"])
is.null(project.data["mediatype"])
is.null(project.data["Brembs"])
is.null(project.data["Brebs"])
is.null(project.data["Bs"])
exists(resources', where=project.data)
exists('resources', where=project.data)
exists('type', where=project.data)
if (exists('type', where=project.data)){ExpType = project.data["type"]} else ExpType = "torquemeter"
load("D:/temp/DTS_test/colorlearning/.RData")
colnames(rawdata)[2]<-"fly"
load("D:/temp/DTS_test/colorlearning/.RData")
colnames(rawdata)[3]<-"fly"
load("~/.RData")
load("D:/temp/DTS_test/colorlearning/.RData")
colnames(rawdata) = gsub("torque", "fly", colnames(rawdata))
colnames(rawdata) = gsub("j_pos", "fly", colnames(rawdata))
flyrange = range(rawdata$fly)
setwd("B:/GitHub/DTSevaluations")
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
View(rawdata)
View(project.data)
View(exp_groups)
View(exp_groups)
texp_groups[[1]] <- c(grp_title, grp_description, xml_list) #add name and description and file links to dataframe to be used in project evaluation document
texp_groups <- list
texp_groups[[1]] <- c(grp_title, grp_description, xml_list) #add name and description and file links to dataframe to be used in project evaluation document
texp_groups <- list
c(grp_title, grp_description, xml_list)
rm(texp_groups
)
text_test <- list()
text_test[[1]] <- c(grp_title, grp_description, xml_list) #add name and description and file links to dataframe to be used in project evaluation document
View(text_test)
text_test[[2]] <- c(grp_title, grp_description, xml_list) #add name and description and file links to dataframe to be used in project evaluation document
exp_groups <- as.data.frame(t(plyr::ldply(text_test, rbind)))
View(exp_groups)
View(exp_groups)
knitr::opts_chunk$set(echo = TRUE)
colnames(exp_groups) = exp_groups[1, ] # make group names to column names
colnames(exp_groups) = as.character(exp_groups[1, ]) # make group names to column names
exp_groups[1, ]
exp_groups <- as.data.frame(t(plyr::ldply(text_test, rbind)))
exp_groups[1, ]
as.character(exp_groups[1, ])
as.character(unlist(exp_groups[1, ]))
unlist(exp_groups[1, ])
colnames(exp_groups) = as.character(unlist(exp_groups[1, ])) # make group names to column names
exp_groups = exp_groups[-1, ,drop=F] #remove the first row which is now column names, without converting to a vector in case of single column
rownames(exp_groups) <- NULL #remove the numbers
kable(exp_groups) #plot table with links to individual fly evaluations
text_test <- list()
text_test[[1]] <- c(grp_title, grp_description, xml_list) #add name and description and file links to dataframe to be used in project evaluation document
exp_groups <- as.data.frame(t(plyr::ldply(text_test, rbind)))
View(exp_groups)
colnames(exp_groups) = as.character(unlist(exp_groups[1, ])) # make group names to column names
exp_groups = exp_groups[-1, ,drop=F] #remove the first row which is now column names, without converting to a vector in case of single column
rownames(exp_groups) <- NULL #remove the numbers
kable(exp_groups) #plot table with links to individual fly evaluations
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
knitr::opts_chunk$set(echo = TRUE)
sampleratecondition <- round(real_sample_rate)>20
cat("<b>Actual samplingrate: </b>", paste(round(real_sample_rate,4)), " Hz; <b>Downsampled sampling rate (target 20 Hz):</b> ", paste(round(down_sample_rate,4)), " Hz")
#plot table of period sequence
periods=t(sequence)
colnames(periods)<-sprintf("Period %s",1:NofPeriods)
grid.table(periods)
##dyplot traces
dytraces(rawdata)
#add columns for PIs to sequence data
sequence$lambda <- NA
for(i in 1:NofPeriods){
#save colors for later plotting
if(sequence$outcome[i]==0){
sequence$color[i]="lightyellow"
sequence$histocolor[i]="darkgreen"
} else {
sequence$color[i]="orange"
sequence$histocolor[i]="orange"
}
if(sequence$contingency[i]==""){
sequence$color[i]=NA
sequence$histocolor[i]="red"
}
##only look at period data
temp  <- rawdata[rawdata$period == i, ]
keeps = c("a_pos","fly")
period.data[[i]] <- temp[keeps] #list only arena position and fly behavior data by period
if(sequence$type[i]=="fs"||sequence$type[i]=="color"||sequence$type[i]=="optomotorR"||sequence$type[i]=="optomotorL")
{
## plot the fly behavior and arena position time traces
fly_pos_traces(temp)
}
##Calculate period histograms
#fly behavior
flyhistos[[i]] <- ggplot(data=temp, aes_string(temp$fly)) +
geom_histogram(binwidth = 3, fill = sequence$histocolor[i]) +
labs(x="Torque [arb units]", y="frequency") +
xlim(maxfly) +
ggtitle(paste(flyname, "Period", i))
#arena position
if(sequence$type[i]=="fs"||sequence$type[i]=="color")
{
poshistos[[i]] <- ggplot(data=temp, aes_string(temp$a_pos)) +
geom_histogram(binwidth=10, fill = sequence$histocolor[i]) +
labs(x="Arena Position [degrees*10]", y="frequency") +
xlim(-1800,1800) +
ggtitle(paste(flyname, "Period", i))
}
##calculate PIs
##create data.frame for adding PIs if it doesn't eist, yet
if(!exists("PIprofile")){PIprofile <- data.frame(matrix(ncol = NofPeriods))}
if(sequence$type[i]=="fs"||sequence$type[i]=="color") #for arena position
{
t1 = sum(abs(temp$a_pos) >= 450 & abs(temp$a_pos) <= 1350)
t2 = nrow(temp)-t1
sequence$lambda[i] = (t1-t2)/(t1+t2)
if (sequence$contingency[i] == '2_4_Q'){sequence$lambda[i]=-sequence$lambda[i]}
if(l==1){PIprofile[1,i]=sequence$lambda[i]}
} else if (sequence$type[i]=="yt" || sequence$type[i]=="sw_blue" || sequence$type[i]=="sw_green") #calculate torque PIs
{
table1 <- table(sign(temp$fly))
t1 = table1[2]
t2 = nrow(temp)-t1
sequence$lambda[i] = (t1-t2)/(t1+t2)
if (sequence$contingency[i] == 'right_torque'){sequence$lambda[i]=-sequence$lambda[i]}
if(l==1){PIprofile[1,i]=sequence$lambda[i]}
}
} #for Number of Periods
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
setwd("B:/GitHub/DTSevaluations")
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
setwd("B:/GitHub/DTSevaluations")
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
save.image("D:/data/DTS_test/t-learn/evaluations/.RData")
