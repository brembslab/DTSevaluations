y=OMdata[[as.character(flyname)]][OMdata$time<=OMmidpoint]                #mean right OM response normalized to positive values
xy <-sortedXyData(x1,y)                                                   #create sortedXYdata object
right<-NLSstAsymptotic(xy)                                                #extract the right turning coefficients into a vector
View(xy)
NLSstAsymptotic(xy)
tryCatch(NLSstAsymptotic(xy))
vari <- 1
tryCatch(print("passes"), error = function(e) print(vari), finally=print("finished"))
tryCatch(stop("fails"), error = function(e) print(vari), finally=print("finished"))
tryCatch(print("passes"), error = function(e) NLSstAsymptotic(xy), finally=print("finished"))
tryCatch(stop("failed"), error = function(e) NLSstAsymptotic(xy), finally=print("finished"))
tryCatch(
expr = {
NLSstAsymptotic(xy)
},
error = function(e){
right="error"
},
warning = function(w){
right="warning"
},
finally = {
}
)
)
tryCatch(
expr = {NLSstAsymptotic(xy)},
error = function(e){ right="error"}
warning = function(w){ },
finally = {  }
)
right="test"
tryCatch(
expr = {NLSstAsymptotic(xy)},
error = function(e){ print("error")}
warning = function(w){ },
finally = {  }
)
tryCatch(
expr = {NLSstAsymptotic(xy)},
error = function(e){ print("error")}
warning = function(w){print("warning")},
finally = { print("finally") })
tryCatch(
expr = {NLSstAsymptotic(xy)},
error = function(e){ right="error"},
warning = function(w){ message('warning')},
finally = {  }
)
tryCatch(
expr = {right=NLSstAsymptotic(xy)},
error = function(e){ right="error"},
warning = function(w){ message('warning')},
finally = {  }
)
tryCatch(
expr = {right<-NLSstAsymptotic(xy)},
error = function(e){ right="error"},
warning = function(w){ message(right="warning"},
finally = {  }
)
tryCatch(
expr = {right<-NLSstAsymptotic(xy)},
error = function(e){ right="error"},
warning = function(w){right="warning"},
finally = {  }
)
rm(right)
tryCatch(
expr = {right<-NLSstAsymptotic(xy)},
error = function(e){ right="error"},
warning = function(w){right="warning"},
finally = {  }
)
tryCatch(
expr = {
right<-NLSstAsymptotic(xy)
return(right)
},
error = function(e){
right="error"
return(right)
},
warning = function(w){
right="warning"
return(right)
},
finally = {  }
)
right=tryCatch(
expr = {
right<-NLSstAsymptotic(xy)
return(right)
},
error = function(e){
right="error"
return(right)
},
warning = function(w){
right="warning"
return(right)
},
finally = {  }
)
NLSstAsymptotic(xy)
right=c(b0=0, b1=0, lrc=0)
right
typeof(right)
typeof(as.numeric(right))
right<-tryCatch(                                                          #extract the right turning coefficients into a vector. Set vector to zero for errors
expr = {
right<-NLSstAsymptotic(xy)
return(right)
},
error = function(e){
right=c(b0=0, b1=0, lrc=0)
return(right)
},
warning = function(w){
right=c(b0=0, b1=0, lrc=0)
return(right)
},
finally = {  }
)
x1=OMdata$time[OMdata$time>OMmidpoint]                      #time
x1=x1-x1[1]                                                 #set time to start from zero
y=-OMdata[[as.character(flyname)]][OMdata$time>OMmidpoint]  #mean left OM response normalized to positive values
xy <-sortedXyData(x1,y)                                     #create sortedXYdata object
left<-tryCatch(                                            #extract the left turning coefficients into a vector. Set vector to zero for errors
expr = {
left<-NLSstAsymptotic(xy)
return(left)
},
error = function(e){
left=c(b0=0, b1=0, lrc=0)
return(left)
},
warning = function(w){
left=c(b0=0, b1=0, lrc=0)
return(left)
},
finally = {  }
)
right[1]
right[2]
(right[1]+right[2]+abs(left[1]+left[2]))/2
setwd("B:/GitHub/DTSevaluations")
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
aveOMcoeff[1]=signif((rightasymp+abs(leftasymp))/2, 3)       #mean asymptote and exponent
aveOMcoeff[1]<-as.vector(signif((rightasymp+abs(leftasymp))/2, 3))       #mean asymptote and exponent
aveOMcoeff=c(signif((rightasymp+abs(leftasymp))/2, 3),       #mean asymptote and exponent
signif((right[3]+left[3])/2, 3),                #mean exponent
signif((abs(rightasymp)-abs(leftasymp))/(abs(rightasymp)+abs(leftasymp)), 3)) #asymmetry index
abs(rightasymp)-abs(leftasymp))/(abs(rightasymp)+abs(leftasymp)
signif((abs(rightasymp)-abs(leftasymp))/(abs(rightasymp)+abs(leftasymp)), 3)
abs(rightasymp)-abs(leftasymp))/(abs(rightasymp)+abs(leftasymp))
(abs(rightasymp)-abs(leftasymp))/(abs(rightasymp)+abs(leftasymp)))
(abs(rightasymp)-abs(leftasymp))/(abs(rightasymp)+abs(leftasymp))
rightasymp
leftasymp
rightasymp+leftasymp
leftasymp==0 & rightasymp==0
rightasymp = right[1]+right[2]
leftasymp = left[1]+left[2]
if(leftasymp==0 & rightasymp==0){
aveOMcoeff=c(0,0,0)
} else {
aveOMcoeff=c(signif((rightasymp+abs(leftasymp))/2, 3),       #mean asymptote and exponent
signif((right[3]+left[3])/2, 3),                #mean exponent
signif((abs(rightasymp)-abs(leftasymp))/(abs(rightasymp)+abs(leftasymp)), 3)) #asymmetry index
}
tempOMparams <- as.data.frame(rbind(as.numeric(aveOMcoeff))) #gather asymptote and halfmaximal time
names(tempOMparams) = c("asymptote", "halfmax_time","AI")    #set column names
rownames(tempOMparams)[1]=as.character(flyname)              #set row names to flynames
kable(tempOMparams)                                          #plot table with data
View(tempOMparams)
exp(aveOMcoeff[3])
-exp(aveOMcoeff[3])
aveOMcoeff[3]=1
exp(aveOMcoeff[3])
exp(10)
exp(-1)
exp(-e)
exp(-2.718282)
setwd("B:/GitHub/DTSevaluations")
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
eval=(!(!'NULL' %in% poshistos))
!(!'NULL' %in% poshistos)
View(poshistos)
'fs' %in% sequence$type
if ('fs' %in% sequence$type) {
poshistos[[NofPeriods+1]] <- ggplot(data=rawdata, aes_string(rawdata$a_pos)) +
geom_histogram(binwidth=10) +
labs(x="position [degrees*10]", y="frequency") +
xlim(-1800,1800) +
ggtitle(paste(flyname, "total"))
}
plot(poshistos[21])
plot(poshistos[[21]])
(!(!'NULL' %in% poshistos))
('fs' %in% sequence$type)
exp(-8.05766)
setwd("B:/GitHub/DTSevaluations")
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
all(is.na(sequence$lambda))
knitr::opts_chunk$set(echo = TRUE)
!all(is.na(sequence$lambda))
PIs <- !all(is.na(sequence$lambda))
setwd("B:/GitHub/DTSevaluations")
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
View(project.data)
is.na(NA)
project.data[["statistics"]][["learning-score"]][["data"]]=NULL
learningscore = project.data[["statistics"]][["learning-score"]][["data"]]
setwd("B:/GitHub/DTSevaluations")
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
setwd("B:/GitHub/DTSevaluations")
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
right<-tryCatch(                                            #extract the right turning coefficients into a vector. Set vector to zero for errors
expr = {
right<-NLSstAsymptotic(xy)
return(right)
},
error = function(e){
right=c(b0=0, b1=0, lrc=0)
return(right)
},
warning = function(w){
right=c(b0=0, b1=0, lrc=0)
return(right)
},
finally = {}
)
left=c(b0 =-272.5213, b1=-502.7470, lrc =-10.2498)
rightasymp = right[1]+right[2]
leftasymp = left[1]+left[2]
signif((abs(rightasymp)+abs(leftasymp))/2, 3)
signif(((exp(right[3])+exp(left[3]))/2)*1000, 3)
exp(right[3])
exp(left[3])
3.536457e-05/2
1.768229e-05*1000
(exp(right[3])+exp(left[3])
)
exp(1)
exp(exp(1))
exp(-exp(1))
-exp(exp(1))
-digamma(1)
exp(2.7182818284590452353602874713527)
exp(-2.7182818284590452353602874713527)
exp(15)
exp(0.000000000000000000000000000000000000001)
exp(0.00000001)
exp(0.1)
exp(0.01)
exp(-0.01)
exp(-1)
exp(-10)
exp(-100)
exp(-1000)
right=c(b0=0, b1=0, lrc=-1000)
exp(right[3])
exp(left[3])
signif(((exp(right[3])+exp(left[3]))/2)*1000, 3),
signif(((exp(right[3])+exp(left[3]))/2)*1000, 3)
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
View(project.data)
project.data$experiment$id
xml_name
xml_name=B:/GitHub/DTSevaluations/example data/OM_joystick/4T4T5Kir1.xml
xml_name="B:/GitHub/DTSevaluations/example data/OM_joystick/4T4T5Kir1.xml"
xml_name
flyData <- xmlParse(xml_name)
flyDataXMLtop = xmlRoot(flyData)
##parse the metadata
URIs <- xmlToDataFrame(nodes=getNodeSet(flyData,"//metadata/URIs"))
experimenter <- xmlToDataFrame(nodes=getNodeSet(flyData,"//metadata/experimenter"))
fly <- xmlToDataFrame(nodes=getNodeSet(flyData,"//metadata/fly"))
experiment <- xmlToDataFrame(nodes=getNodeSet(flyData,"//metadata/experiment"))
##parse sequence data
NofPeriods = as.integer(xmlGetAttr(flyDataXMLtop[['sequence']], "periods"))
sequence <- xmlToDataFrame(nodes=getNodeSet(flyData,"//sequence/period"))
##parse time series meta-data
CSV_descriptor <- xmlToDataFrame(nodes=getNodeSet(flyData,"//timeseries/CSV_descriptor"))
variables <- xmlToDataFrame(nodes=getNodeSet(flyData,"//timeseries/variables/variable"))
##parse the time series raw data
rawdata <- read.table(text=xmlSApply(flyDataXMLtop[['timeseries']][['csv_data']], xmlValue), col.names=variables$type)
##reset periods to start from 1 of they start from 0
if (rawdata$period[1]==0){rawdata$period=rawdata$period+1}
##reset position data to +/-180Â° [-1800..1796] for torquemeter experiments
if (project.data$experiment$type=="Torquemeter"){
if (experiment$arena_type=="lightguides"){rawdata$a_pos = rawdata$a_pos-1800}
if (experiment$arena_type=="motor"){rawdata$a_pos = round(rawdata$a_pos*0.87890625)}
}
##change j_pos data from float to integer and shift to make approx. zero symmetric (needs work!)
if(exists("j_pos", rawdata)){
rawdata$j_pos = round(rawdata$j_pos*1000)+1100
}
##change a_pos data from float to integer in Joystick experiments
if(experiment$meter_type=="Joystick"){
rawdata$a_pos = round(rawdata$a_pos*1000)
}
##replace column name for fly behavior (torque, j_pos) with "fly"
colnames(rawdata) = gsub("torque", "fly", colnames(rawdata))
colnames(rawdata) = gsub("j_pos", "fly", colnames(rawdata))
##find range of fly behavior values
flyrange = range(rawdata$fly)
##calculate actual sampling rate and downsample if necessary
real_sample_rate = nrow(rawdata)/(rawdata$time[nrow(rawdata)]/1000)
difference = as.data.frame(table(rawdataDown$period)) #generate dataframe with actual numbers of data points
difference$duration = as.numeric(as.character(sequence$duration))*20 # add column with expected values from sequence$duration @ 20Hz
difference$deviation = difference$Freq-difference$duration
if(any(abs(as.numeric(difference$deviation))>1)) stop("Number of data points does not match expectations. Check DTS Rawdata!") #check if there is more than one missing/additional data point
diff_periods = rownames(difference)[difference$deviation!=0] #find periods with differing numbers of data points
#mark the last data pont of each offending period (assuming we're only one data point off!)
if (length(diff_periods)!=0){
rawdataDown$last = NA
rawdataDown$last = with(rawdataDown, ave(last, match(rawdataDown$period, diff_periods), FUN = function(x) ifelse(seq_along(x) == length(x), 1, x))) # "1" marking the last data pÃ¼oint in an offending period
#mark the last data points of periods with missing data points
if (length(rownames(difference)[difference$deviation==-1])!=0){ #if there are periods with too few data points, duplicate the last
negative_periods=rownames(difference)[difference$deviation==-1] #find the periods with missing values
rawdataDown$last = with(rawdataDown, ave(last, match(rawdataDown$period, negative_periods), FUN = function(x) ifelse(seq_along(x) == length(x), 2, x))) # "2" marking the last data pÃ¼oint in an offending period
copy = as.vector(rawdataDown[is.element(rawdataDown$last, 2),])
copy$last=NA
for (z in 1:length(negative_periods)) {
temp.pos=as.numeric(rownames(copy[z,])) #find the right position to insert
next.pos=temp.pos+1                     #for some reason, R also wants to have the next position as a variable
rawdataDown <- rbind(rawdataDown[1:temp.pos,], copy[z,], rawdataDown[next.pos:nrow(rawdataDown),]) # duplicate the last data point in the offending periods
}
}
rawdataDown <- rawdataDown[!(grepl(1, rawdataDown$last)),] # delete last data point of the offending periods
rawdataDown$last <- NULL #delete the unnecessary 'last' column
rawdataDown$time = seq(0, (as.numeric(as.character(experiment$duration))*1000)-50, by=50) # fix the mangled time column
row.names(rawdataDown) <- 1:nrow(rawdataDown) #fix rownames, too
}
rawdata$group_num <- 50*round(rawdata$time/50) # Create 50ms bins
rawdata$weight <- 1/(1+abs(rawdata$time-rawdata$group_num)) # calculate distance from measurement point
rawdata$norm <-ave(rawdata$weight,rawdata$group_num,FUN=function(x) x/sum(x)) #apply weights according to distance from bin center
rawdata$fly2 <- rawdata$fly*rawdata$norm
rawdata$a_pos2 <- rawdata$a_pos*rawdata$norm #needs more work because of values at +/-180Â°!!!
rawdata$period2 <- rawdata$period*rawdata$norm
# create the vectors in which to save the downsampled data
timeDownsampled <- as.vector(unique(rawdata$group_num))
a_posDownsampled <- as.vector(round(tapply(rawdata$a_pos2, rawdata$group_num, sum)))
flyDownsampled <- as.vector(round(tapply(rawdata$fly2, rawdata$group_num, sum)))
periodDownsampled <- as.vector(round(tapply(rawdata$period2, rawdata$group_num, sum)))
# bind the downsampled vectors into one dataframe
rawdataDown <- data.frame("time" = timeDownsampled, "a_pos" = a_posDownsampled, "fly" = flyDownsampled, "period" = periodDownsampled)
### check the dataframe for consistency
if (length(table(rawdataDown$period)) > NofPeriods) {rawdataDown<-rawdataDown[!(rawdataDown$period==length(table(rawdataDown$period))),]} #remove any extra period numbers, if they exist
# check if there are periods which deviate from projected duration
difference = as.data.frame(table(rawdataDown$period)) #generate dataframe with actual numbers of data points
difference$duration = as.numeric(as.character(sequence$duration))*20 # add column with expected values from sequence$duration @ 20Hz
difference$deviation = difference$Freq-difference$duration
if(any(abs(as.numeric(difference$deviation))>1)) stop("Number of data points does not match expectations. Check DTS Rawdata!") #check if there is more than one missing/additional data point
diff_periods = rownames(difference)[difference$deviation!=0] #find periods with differing numbers of data points
#mark the last data pont of each offending period (assuming we're only one data point off!)
if (length(diff_periods)!=0){
rawdataDown$last = NA
rawdataDown$last = with(rawdataDown, ave(last, match(rawdataDown$period, diff_periods), FUN = function(x) ifelse(seq_along(x) == length(x), 1, x))) # "1" marking the last data pÃ¼oint in an offending period
#mark the last data points of periods with missing data points
if (length(rownames(difference)[difference$deviation==-1])!=0){ #if there are periods with too few data points, duplicate the last
negative_periods=rownames(difference)[difference$deviation==-1] #find the periods with missing values
rawdataDown$last = with(rawdataDown, ave(last, match(rawdataDown$period, negative_periods), FUN = function(x) ifelse(seq_along(x) == length(x), 2, x))) # "2" marking the last data pÃ¼oint in an offending period
copy = as.vector(rawdataDown[is.element(rawdataDown$last, 2),])
copy$last=NA
for (z in 1:length(negative_periods)) {
temp.pos=as.numeric(rownames(copy[z,])) #find the right position to insert
next.pos=temp.pos+1                     #for some reason, R also wants to have the next position as a variable
rawdataDown <- rbind(rawdataDown[1:temp.pos,], copy[z,], rawdataDown[next.pos:nrow(rawdataDown),]) # duplicate the last data point in the offending periods
}
}
rawdataDown <- rawdataDown[!(grepl(1, rawdataDown$last)),] # delete last data point of the offending periods
rawdataDown$last <- NULL #delete the unnecessary 'last' column
rawdataDown$time = seq(0, (as.numeric(as.character(experiment$duration))*1000)-50, by=50) # fix the mangled time column
row.names(rawdataDown) <- 1:nrow(rawdataDown) #fix rownames, too
}
rawdata=rawdataDown
rightOMperiods=which(grepl("optomotorR", sequence$type)) #collect the right turning OM periods
rightOMdata<-filter(rawdata, rawdata$period %in% rightOMperiods) #extract only right turning arena periods
rightOMdata <- rightOMdata %>% select(-c(a_pos,date)) #drop unnecessary columns
rightOMperiods=which(grepl("optomotorR", sequence$type)) #collect the right turning OM periods
rightOMdata<-filter(rawdata, rawdata$period %in% rightOMperiods) #extract only right turning arena periods
rightOMdata <- rightOMdata %>% select(-c(a_pos)) #drop unnecessary columns
rightOMdata$time=ave(rightOMdata$period, rightOMdata$period, FUN=seq_along) #match the time values to start at each period start
rightOMdata$time=(rightOMdata$time-1)*50 #make 20Hz data into ms time scale
rightOMdata$period=as.factor(rightOMdata$period)
leftOMperiods=which(grepl("optomotorL", sequence$type)) #collect the left turning OM periods
leftOMdata<-filter(rawdata, rawdata$period %in% leftOMperiods)  #extract only left turning arena periods
leftOMdata <- leftOMdata %>% select(-c(a_pos))  #drop unnecessary columns
leftOMdata$time=ave(leftOMdata$period, leftOMdata$period, FUN=seq_along) #match the time values to start at each period start
leftOMdata$time=((leftOMdata$time)*50)+max(rightOMdata$time) #make 20Hz data into ms time scale, starting after right turning data
leftOMdata$period=as.factor(leftOMdata$period)
tempOMdata=rbind(rightOMdata,leftOMdata) #combine left and right OMdata in one dataframe
tempOMdata=aggregate(tempOMdata$fly,FUN=mean,by=list(tempOMdata$time)) #average across periods
colnames(tempOMdata) <- c("time", as.character(flyname)) #set dataframe names
if(!exists("OMdata"))
{
OMdata=tempOMdata
} else {
OMdata[[as.character(flyname)]]=tempOMdata[[as.character(flyname)]]
}
ggplot(data=OMdata, aes(x=OMdata$time, y=OMdata[[as.character(flyname)]])) +
geom_line() +
ylab("Optomotor Resoponse [rel. units]")+
xlab("Time [ms]")
OMmidpoint = OMdata$time[nrow(OMdata)]/2
x1=OMdata$time[OMdata$time<=OMmidpoint]                     #time
y=OMdata[[as.character(flyname)]][OMdata$time<=OMmidpoint]  #mean right OM response normalized to positive values
xy <-sortedXyData(x1,y)                                     #create sortedXYdata object
NLSstAsymptotic(xy)
plot(xy)
third_order(xy,fit3)
m<-nls(y~b0 + b1*(1-exp(-exp(lrc) * x1)))
m<-nls(y~b0 + b1*(1-exp(-exp(lrc) * x1)), start = list(b0=162, b1=240, lrc=-8))
m<-nls(y~b0 + b1*(1-exp(-exp(lrc) * x1)), start = list(b0=150, b1=200, lrc=-6))
m<-nls(y~b0 + b1*(1-exp(-exp(lrc) * x1)), start = list(b0=100, b1=300, lrc=-6))
leftasymp < maxfly[1]
rightasymp > maxfly[2]
rightasymp = right[1]+right[2]
leftasymp = left[1]+left[2]
leftasymp < maxfly[1]
rightasymp > maxfly[2]
x1=OMdata$time[OMdata$time<=OMmidpoint]                     #time
y=OMdata[[as.character(flyname)]][OMdata$time<=OMmidpoint]  #mean right OM response normalized to positive values
xy <-sortedXyData(x1,y)                                     #create sortedXYdata object
right<-tryCatch(                                            #extract the right turning coefficients into a vector. Set vector to zero for errors
expr = {
right<-NLSstAsymptotic(xy)
return(right)
},
error = function(e){
right=c(b0=0, b1=0, lrc=-1000)        #set logarithmic rate constant to -1000 so exp(lrc)=0
return(right)
},
warning = function(w){
right=c(b0=0, b1=0, lrc=-1000)        #set logarithmic rate constant to -1000 so exp(lrc)=0
return(right)
},
finally = {}
)
x1=OMdata$time[OMdata$time>OMmidpoint]                      #time
x1=x1-x1[1]                                                 #set time to start from zero
y=OMdata[[as.character(flyname)]][OMdata$time>OMmidpoint]   #mean left OM response normalized to positive values
xy <-sortedXyData(x1,y)                                     #create sortedXYdata object
left<-tryCatch(                                             #extract the left turning coefficients into a vector. Set vector to zero for errors
expr = {
left<-NLSstAsymptotic(xy)
return(left)
},
error = function(e){
left=c(b0=0, b1=0, lrc=-1000)         #set logarithmic rate constant to -1000 so exp(lrc)=0
return(left)
},
warning = function(w){
left=c(b0=0, b1=0, lrc=-1000)         #set logarithmic rate constant to -1000 so exp(lrc)=0
return(left)
},
finally = {}
)
rightasymp = right[1]+right[2]
leftasymp = left[1]+left[2]
NLSstAsymptotic(xy)
left<-tryCatch(                                             #extract the left turning coefficients into a vector. Set vector to zero for errors
expr = {
left<-NLSstAsymptotic(xy)
return(left)
},
error = function(e){
left=c(b0=0, b1=0, lrc=-1000)         #set logarithmic rate constant to -1000 so exp(lrc)=0
return(left)
},
warning = function(w){
left=c(b0=0, b1=0, lrc=-1000)         #set logarithmic rate constant to -1000 so exp(lrc)=0
return(left)
},
finally = {}
)
left<-NLSstAsymptotic(xy)
right<-NLSstAsymptotic(xy)
x1=OMdata$time[OMdata$time<=OMmidpoint]                     #time
y=OMdata[[as.character(flyname)]][OMdata$time<=OMmidpoint]  #mean right OM response normalized to positive values
xy <-sortedXyData(x1,y)                                     #create sortedXYdata object
right<-NLSstAsymptotic(xy)
x1=OMdata$time[OMdata$time>OMmidpoint]                      #time
x1=x1-x1[1]                                                 #set time to start from zero
y=OMdata[[as.character(flyname)]][OMdata$time>OMmidpoint]   #mean left OM response normalized to positive values
xy <-sortedXyData(x1,y)                                     #create sortedXYdata object
left<-NLSstAsymptotic(xy)
rightasymp = right[1]+right[2]
leftasymp = left[1]+left[2]
leftasymp < maxfly[1]
rightasymp > maxfly[2]
right<-tryCatch(                                            #extract the right turning coefficients into a vector. Set vector to zero for errors
expr = {
right<-NLSstAsymptotic(xy)
return(right)
},
error = function(e){
right=c(b0=0, b1=0, lrc=-1000)        #set logarithmic rate constant to -1000 so exp(lrc)=0
return(right)
},
warning = function(w){
right=c(b0=0, b1=0, lrc=-1000)        #set logarithmic rate constant to -1000 so exp(lrc)=0
return(right)
},
finally = {}
)
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
View(plotOMparams)
