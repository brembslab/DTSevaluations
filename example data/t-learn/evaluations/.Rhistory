y2=-plotOM$means[plotOM$time>OMmidpoint] #mean OM response
y2=y2+abs(y2[1])
m2<-nls(y2~a*x2/(b+x2))
plot(x1,y1)
lines(x1,predict(m1),lty=2,col="red",lwd=3)
plot(x2,y2)
lines(x2,predict(m2),lty=2,col="red",lwd=3)
summary(m1)
summary(m2)
OMmidpoint = plotOM$time[nrow(plotOM)]/2
#right turning traces
x=plotOM$time[plotOM$time<=OMmidpoint] #time
y=plotOM$means[plotOM$time<=OMmidpoint]+abs(plotOM$means[1]) #mean OM response normalized to start from zero
m<-nls(y~a*x/(b+x))
OMparams=as.data.frame(coef(m)) #put the results in a dataframe
View(OMparams)
test=coef(m)
test
OMmidpoint = plotOM$time[nrow(plotOM)]/2
#right turning traces
x=plotOM$time[plotOM$time<=OMmidpoint] #time
y=plotOM$means[plotOM$time<=OMmidpoint]+abs(plotOM$means[1]) #mean OM response normalized to start from zero
m<-nls(y~a*x/(b+x))
right=coef(m) #put the results in a vector
#left turning traces
x=plotOM$time[plotOM$time>OMmidpoint] #time
x=x-x[1] #set time to start from zero
y=-plotOM$means[plotOM$time>OMmidpoint] #mean OM response
y=y+abs(y[1])
m<-nls(y~a*x/(b+x))
left=coef(m)
mean(left, right)
(left+right)/2
(left-right)
(left-right)/(left+right)
(right-left)/(right+left)
as_slope=(right+left)/2 #mean asymptote and slope
asym_ind=(right-left)/(right+left) #asymmetry index
plot(as_slope)
barplot(as_slope)
barplot(asym_ind)
aveOMcoeff=(right+left)/2                                    #mean asymptote and halfmaximal time
OMasym=(right-left)/(right+left)                             #asymmetry index
aveOMcoeff[2]=aveOMcoeff[2]/1000
OMparams <- c(avecoeff, OMasym[1])
OMparams <- data.frame(avecoeff, OMasym[1])
OMparams <- data.frame(aveOMcoeff, OMasym[1])
View(OMparams)
as.numeric(aveOMcoeff)
OMparams <- data.frame(as.numeric(aveOMcoeff), as.numeric(OMasym[1]))
OMparams <- cbind(as.numeric(aveOMcoeff), as.numeric(OMasym[1]))
OMparams <- rbind(as.numeric(aveOMcoeff), as.numeric(OMasym[1]))
OMparams <- data.frame(as.numeric(aveOMcoeff))
OMparams <- rbind(as.numeric(aveOMcoeff))
OMparams$3 <- as.numeric(OMasym[1])
OMparams$v3 <- as.numeric(OMasym[1])
View(OMparams)
OMparams <- rbind(as.numeric(aveOMcoeff))
OMparams$v3 = as.numeric(OMasym[1])
OMparams <- rbind(as.numeric(aveOMcoeff))
OMparams$v3 = OMasym[1]
OMparams <- rbind(as.numeric(aveOMcoeff))
OMparams$v3 = as.data.frame(OMasym[1])
OMparams <- as.data.frame(rbind(as.numeric(aveOMcoeff)))
OMparams$v3 = as.data.frame(OMasym[1])
View(OMparams)
OMparams <- as.data.frame(rbind(as.numeric(aveOMcoeff)))
OMparams$v3 = OMasym[1]
View(OMparams)
kable(OMparams)
library(ggplot2)
library(tidyr)
library(dygraphs)
library(grid)
library(reshape2)
library(dplyr)
library(gridExtra)
library(yaml)
library(ggsignif)
library(effsize)
library(pwr)
library(BayesFactor)
library(genefilter)  # if not available for newest version: setRepositories(addURLs = c(CRANxtras = "http://www.stats.ox.ac.uk/pub/RWin"))
library(seewave)
kable(OMparams)
names(OMparams) = c("asymptote", "halfmax_time","AI")
View(OMparams)
tempOMparams <- as.data.frame(rbind(as.numeric(aveOMcoeff))) #gather asymptote and halfmaximal time
tempOMparams$v3 = OMasym[1]                                  #add asymptote asymmetry index
names(tempOMparams) = c("asymptote", "halfmax_time","AI")
rownames(tempOMparams[1])=flyname
View(tempOMparams)
flyname
as.character(flyname)
rownames(tempOMparams[1])=as.character(flyname)
View(tempOMparams)
rownames(tempOMparams[1])=as.character(flyname)
View(tempOMparams)
rownames(tempOMparams[1])
rownames(tempOMparams[1])=as.character(flyname)
rownames(tempOMparams[1])
rownames(tempOMparams)[1]=as.character(flyname)
View(tempOMdata)
View(tempOMparams)
library(knitr)
kable
kable(tempOMparams)
if(!exists("OMparams"))
{
OMparams=tempOMparams
} else {
OMparams[as.character(flyname),]=tempOMparams
}
View(OMparams)
rm(OMparams)
if(!exists("OMparams"))
{
OMparams=tempOMparams
} else {
OMparams[as.character(flyname),]=tempOMparams
}
View(OMparams)
if(!exists("OMparams"))
{
OMparams=tempOMparams
} else {
OMparams[as.character(flyname),]=tempOMparams
}
if(!exists("OMparams"))
{
OMparams=tempOMparams
} else {
OMparams[as.character(flyname),]=tempOMparams
}
View(OMparams)
View(OMparams)
OMparams[as.character(flyname),]=tempOMparams
rownames(OMparams)[1]=wtb-01
rownames(OMparams)[1]="wtb-01"
View(OMparams)
if(!exists("OMparams"))
{
OMparams=tempOMparams
} else {
OMparams[as.character(flyname),]=tempOMparams
}
View(OMparams)
load("B:/GitHub/DTSevaluations/.RData")
View(PIprofile)
View(PIstat)
load("B:/GitHub/DTSevaluations/example data/t-learn/evaluations/.RData")
paste("<a href=\"", xml_name, "\"">, flyname, "</a>)
knitr::opts_chunk$set(echo = TRUE)
paste("<a href=\""> #, xml_name, "\"">, flyname, "</a>)
paste("<a href=\"">)
paste("<a href=\"")
paste('<a href="')
paste('<a href="', xml_name, '">', flyname, '</a>')
basename(xml_name)
paste('<a href="../', basename(xml_name), '">', flyname, '</a>')
paste('<a href="../', basename(xml_name), '">', flyname, '</a>', sep = "")
paste('<a href="../', basename(xml_name), '">', flyname, '</a>', sep = "")
paste('<a href="../', basename(project.file), '">', project.data$title, '</a>', sep = "")
load("B:/GitHub/DTSevaluations/example data/t-learn/evaluations/.RData")
View(tempOMdata)
View(rightOMdata)
View(tempOMdata)
View(tempOMdata)
xy
knitr::opts_chunk$set(echo = TRUE)
xy <-sortedXyData(x1,y)
plot(xy)
View(xy)
typeof(xy)
right
NLSstAsymptotic(xy)
exp(-1000)
left<-tryCatch(                                             #extract the left turning coefficients into a vector. Set vector to zero for errors
expr = {
left<-NLSstAsymptotic(xy)
return(left)
},
error = function(e){
left=c(b0=0, b1=0, lrc=-1000)         #set logarithmic rate constant to -1000 so exp(lrc)=0
return(left)
},
warning = function(w){
left=c(b0=0, b1=0, lrc=-1000)         #set logarithmic rate constant to -1000 so exp(lrc)=0
return(left)
},
finally = {}
)
View(grouped.OMdata)
View(plotOM)
View(project.data)
knitr::opts_chunk$set(echo = TRUE)
lm(x1 ~ y, data = xy)
plot(xy)
tem = lm(x1 ~ y, data = xy)
summary(tem)
plot(tem)
xyplot(tem)
abline(tem)
abline(tem)
plot(xy)
abline(tem)
tem = lm(y ~ x, data = xy)
plot(xy)
abline(tem)
summary(tem)
View(tem)
tem$coefficients
tem$coefficients[2]
tem$coefficients[2]<0.1
xml_name
xml_name=B:/GitHub/DTSevaluations/example data/t-learn/wtb-03.xml
xml_name="B:/GitHub/DTSevaluations/example data/t-learn/wtb-03.xml"
flyData <- xmlParse(xml_name)
flyDataXMLtop = xmlRoot(flyData)
##parse the metadata
URIs <- xmlToDataFrame(nodes=getNodeSet(flyData,"//metadata/URIs"))
experimenter <- xmlToDataFrame(nodes=getNodeSet(flyData,"//metadata/experimenter"))
fly <- xmlToDataFrame(nodes=getNodeSet(flyData,"//metadata/fly"))
experiment <- xmlToDataFrame(nodes=getNodeSet(flyData,"//metadata/experiment"))
##parse sequence data
NofPeriods = as.integer(xmlGetAttr(flyDataXMLtop[['sequence']], "periods"))
sequence <- xmlToDataFrame(nodes=getNodeSet(flyData,"//sequence/period"))
##parse time series meta-data
CSV_descriptor <- xmlToDataFrame(nodes=getNodeSet(flyData,"//timeseries/CSV_descriptor"))
variables <- xmlToDataFrame(nodes=getNodeSet(flyData,"//timeseries/variables/variable"))
##parse the time series raw data
rawdata <- read.table(text=xmlSApply(flyDataXMLtop[['timeseries']][['csv_data']], xmlValue), col.names=variables$type)
##reset periods to start from 1 of they start from 0
if (rawdata$period[1]==0){rawdata$period=rawdata$period+1}
##reset position data to +/-180° [-1800..1796] for torquemeter experiments
if (project.data$experiment$type=="Torquemeter"){
if (experiment$arena_type=="lightguides"){rawdata$a_pos = rawdata$a_pos-1800}
if (experiment$arena_type=="motor"){rawdata$a_pos = round(rawdata$a_pos*0.87890625)}
}
##change j_pos data from float to integer and shift to make approx. zero symmetric (needs work!)
if(exists("j_pos", rawdata)){
rawdata$j_pos = round(rawdata$j_pos*1000)+1100
}
##change a_pos data from float to integer in Joystick experiments
if(experiment$meter_type=="Joystick"){
rawdata$a_pos = round(rawdata$a_pos*1000)
}
##replace column name for fly behavior (torque, j_pos) with "fly"
colnames(rawdata) = gsub("torque", "fly", colnames(rawdata))
colnames(rawdata) = gsub("j_pos", "fly", colnames(rawdata))
##find range of fly behavior values
flyrange = range(rawdata$fly)
##calculate actual sampling rate and downsample if necessary
real_sample_rate = nrow(rawdata)/(rawdata$time[nrow(rawdata)]/1000)
rawdata$group_num <- 50*round(rawdata$time/50) # Create 50ms bins
rawdata$weight <- 1/(1+abs(rawdata$time-rawdata$group_num)) # calculate distance from measurement point
rawdata$norm <-ave(rawdata$weight,rawdata$group_num,FUN=function(x) x/sum(x)) #apply weights according to distance from bin center
rawdata$fly2 <- rawdata$fly*rawdata$norm
rawdata$a_pos2 <- rawdata$a_pos*rawdata$norm #needs more work because of values at +/-180°!!!
rawdata$period2 <- rawdata$period*rawdata$norm
# create the vectors in which to save the downsampled data
timeDownsampled <- as.vector(unique(rawdata$group_num))
a_posDownsampled <- as.vector(round(tapply(rawdata$a_pos2, rawdata$group_num, sum)))
flyDownsampled <- as.vector(round(tapply(rawdata$fly2, rawdata$group_num, sum)))
periodDownsampled <- as.vector(round(tapply(rawdata$period2, rawdata$group_num, sum)))
# bind the downsampled vectors into one dataframe
rawdataDown <- data.frame("time" = timeDownsampled, "a_pos" = a_posDownsampled, "fly" = flyDownsampled, "period" = periodDownsampled)
### check the dataframe for consistency
if (length(table(rawdataDown$period)) > NofPeriods) {rawdataDown<-rawdataDown[!(rawdataDown$period==length(table(rawdataDown$period))),]} #remove any extra period numbers, if they exist
# check if there are periods which deviate from projected duration
difference = as.data.frame(table(rawdataDown$period)) #generate dataframe with actual numbers of data points
difference$duration = as.numeric(as.character(sequence$duration))*20 # add column with expected values from sequence$duration @ 20Hz
difference$deviation = difference$Freq-difference$duration
if(any(abs(as.numeric(difference$deviation))>1)) stop("Number of data points does not match expectations. Check DTS Rawdata!") #check if there is more than one missing/additional data point
diff_periods = rownames(difference)[difference$deviation!=0] #find periods with differing numbers of data points
#mark the last data pont of each offending period (assuming we're only one data point off!)
if (length(diff_periods)!=0){
rawdataDown$last = NA
rawdataDown$last = with(rawdataDown, ave(last, match(rawdataDown$period, diff_periods), FUN = function(x) ifelse(seq_along(x) == length(x), 1, x))) # "1" marking the last data püoint in an offending period
#mark the last data points of periods with missing data points
if (length(rownames(difference)[difference$deviation==-1])!=0){ #if there are periods with too few data points, duplicate the last
negative_periods=rownames(difference)[difference$deviation==-1] #find the periods with missing values
rawdataDown$last = with(rawdataDown, ave(last, match(rawdataDown$period, negative_periods), FUN = function(x) ifelse(seq_along(x) == length(x), 2, x))) # "2" marking the last data püoint in an offending period
copy = as.vector(rawdataDown[is.element(rawdataDown$last, 2),])
copy$last=NA
for (z in 1:length(negative_periods)) {
temp.pos=as.numeric(rownames(copy[z,])) #find the right position to insert
next.pos=temp.pos+1                     #for some reason, R also wants to have the next position as a variable
rawdataDown <- rbind(rawdataDown[1:temp.pos,], copy[z,], rawdataDown[next.pos:nrow(rawdataDown),]) # duplicate the last data point in the offending periods
}
}
rawdataDown <- rawdataDown[!(grepl(1, rawdataDown$last)),] # delete last data point of the offending periods
rawdataDown$last <- NULL #delete the unnecessary 'last' column
rawdataDown$time = seq(0, (as.numeric(as.character(experiment$duration))*1000)-50, by=50) # fix the mangled time column
row.names(rawdataDown) <- 1:nrow(rawdataDown) #fix rownames, too
}
rawdata=rawdataDown
rightOMperiods=which(grepl("optomotorR", sequence$type)) #collect the right turning OM periods
rightOMdata<-filter(rawdata, rawdata$period %in% rightOMperiods) #extract only right turning arena periods
rightOMdata <- rightOMdata %>% select(-c(a_pos,date)) #drop unnecessary columns
library(ggplot2)
library(tidyr)
library(dygraphs)
library(grid)
library(reshape2)
library(dplyr)
library(gridExtra)
library(yaml)
library(ggsignif)
library(effsize)
library(pwr)
library(BayesFactor)
library(genefilter)  # if not available for newest version: setRepositories(addURLs = c(CRANxtras = "http://www.stats.ox.ac.uk/pub/RWin"))
library(seewave)
## source the script with the functions needed for analysis
source("readXMLdatafile.R")
source("DTS_plotfunctions.R")
rightOMperiods=which(grepl("optomotorR", sequence$type)) #collect the right turning OM periods
rightOMdata<-filter(rawdata, rawdata$period %in% rightOMperiods) #extract only right turning arena periods
rightOMdata <- rightOMdata %>% select(-c(a_pos,date)) #drop unnecessary columns
rightOMdata <- rightOMdata %>% select(-c(a_pos)) #drop unnecessary columns
rightOMdata$time=ave(rightOMdata$period, rightOMdata$period, FUN=seq_along) #match the time values to start at each period start
rightOMdata$time=(rightOMdata$time-1)*50 #make 20Hz data into ms time scale
rightOMdata$period=as.factor(rightOMdata$period)
ggplot(data = rightOMdata, aes(x=time, y=fly)) +
geom_line(aes(group=period, colour=period), size=1) +
geom_smooth(method="loess", span = 0.1) +
ylab("Optomotor Resoponse [rel. units]")+
xlab("Time [ms]") +
ggtitle(paste("Right (clockwise) arena rotations -", flyname))
xml_name
View(rawdataDown)
View(rawdata)
View(rawdataDown)
flyData <- xmlParse(xml_name)
flyDataXMLtop = xmlRoot(flyData)
URIs <- xmlToDataFrame(nodes=getNodeSet(flyData,"//metadata/URIs"))
experimenter <- xmlToDataFrame(nodes=getNodeSet(flyData,"//metadata/experimenter"))
fly <- xmlToDataFrame(nodes=getNodeSet(flyData,"//metadata/fly"))
experiment <- xmlToDataFrame(nodes=getNodeSet(flyData,"//metadata/experiment"))
##parse sequence data
NofPeriods = as.integer(xmlGetAttr(flyDataXMLtop[['sequence']], "periods"))
sequence <- xmlToDataFrame(nodes=getNodeSet(flyData,"//sequence/period"))
##parse time series meta-data
CSV_descriptor <- xmlToDataFrame(nodes=getNodeSet(flyData,"//timeseries/CSV_descriptor"))
variables <- xmlToDataFrame(nodes=getNodeSet(flyData,"//timeseries/variables/variable"))
rawdata <- read.table(text=xmlSApply(flyDataXMLtop[['timeseries']][['csv_data']], xmlValue), col.names=variables$type)
##reset periods to start from 1 of they start from 0
if (rawdata$period[1]==0){rawdata$period=rawdata$period+1}
##reset position data to +/-180° [-1800..1796] for torquemeter experiments
if (project.data$experiment$type=="Torquemeter"){
if (experiment$arena_type=="lightguides"){rawdata$a_pos = rawdata$a_pos-1800}
if (experiment$arena_type=="motor"){rawdata$a_pos = round(rawdata$a_pos*0.87890625)}
}
##change j_pos data from float to integer and shift to make approx. zero symmetric (needs work!)
if(exists("j_pos", rawdata)){
rawdata$j_pos = round(rawdata$j_pos*1000)+1100
}
##change a_pos data from float to integer in Joystick experiments
if(experiment$meter_type=="Joystick"){
rawdata$a_pos = round(rawdata$a_pos*1000)
}
##replace column name for fly behavior (torque, j_pos) with "fly"
colnames(rawdata) = gsub("torque", "fly", colnames(rawdata))
colnames(rawdata) = gsub("j_pos", "fly", colnames(rawdata))
##find range of fly behavior values
flyrange = range(rawdata$fly)
##calculate actual sampling rate and downsample if necessary
real_sample_rate = nrow(rawdata)/(rawdata$time[nrow(rawdata)]/1000)
rawdata$group_num <- 50*round(rawdata$time/50) # Create 50ms bins
rawdata$weight <- 1/(1+abs(rawdata$time-rawdata$group_num)) # calculate distance from measurement point
rawdata$norm <-ave(rawdata$weight,rawdata$group_num,FUN=function(x) x/sum(x)) #apply weights according to distance from bin center
rawdata$fly2 <- rawdata$fly*rawdata$norm
rawdata$a_pos2 <- rawdata$a_pos*rawdata$norm #needs more work because of values at +/-180°!!!
rawdata$period2 <- rawdata$period*rawdata$norm
# create the vectors in which to save the downsampled data
timeDownsampled <- as.vector(unique(rawdata$group_num))
a_posDownsampled <- as.vector(round(tapply(rawdata$a_pos2, rawdata$group_num, sum)))
flyDownsampled <- as.vector(round(tapply(rawdata$fly2, rawdata$group_num, sum)))
periodDownsampled <- as.vector(round(tapply(rawdata$period2, rawdata$group_num, sum)))
# bind the downsampled vectors into one dataframe
rawdataDown <- data.frame("time" = timeDownsampled, "a_pos" = a_posDownsampled, "fly" = flyDownsampled, "period" = periodDownsampled)
### check the dataframe for consistency
if (length(table(rawdataDown$period)) > NofPeriods) {rawdataDown<-rawdataDown[!(rawdataDown$period==length(table(rawdataDown$period))),]} #remove any extra period numbers, if they exist
# check if there are periods which deviate from projected duration
difference = as.data.frame(table(rawdataDown$period)) #generate dataframe with actual numbers of data points
difference$duration = as.numeric(as.character(sequence$duration))*20 # add column with expected values from sequence$duration @ 20Hz
difference$deviation = difference$Freq-difference$duration
if(any(abs(as.numeric(difference$deviation))>1)) stop("Number of data points does not match expectations. Check DTS Rawdata!") #check if there is more than one missing/additional data point
diff_periods = rownames(difference)[difference$deviation!=0] #find periods with differing numbers of data points
#mark the last data pont of each offending period (assuming we're only one data point off!)
if (length(diff_periods)!=0){
rawdataDown$last = NA
rawdataDown$last = with(rawdataDown, ave(last, match(rawdataDown$period, diff_periods), FUN = function(x) ifelse(seq_along(x) == length(x), 1, x))) # "1" marking the last data püoint in an offending period
#mark the last data points of periods with missing data points
if (length(rownames(difference)[difference$deviation==-1])!=0){ #if there are periods with too few data points, duplicate the last
negative_periods=rownames(difference)[difference$deviation==-1] #find the periods with missing values
rawdataDown$last = with(rawdataDown, ave(last, match(rawdataDown$period, negative_periods), FUN = function(x) ifelse(seq_along(x) == length(x), 2, x))) # "2" marking the last data püoint in an offending period
copy = as.vector(rawdataDown[is.element(rawdataDown$last, 2),])
copy$last=NA
for (z in 1:length(negative_periods)) {
temp.pos=as.numeric(rownames(copy[z,])) #find the right position to insert
next.pos=temp.pos+1                     #for some reason, R also wants to have the next position as a variable
rawdataDown <- rbind(rawdataDown[1:temp.pos,], copy[z,], rawdataDown[next.pos:nrow(rawdataDown),]) # duplicate the last data point in the offending periods
}
}
rawdataDown <- rawdataDown[!(grepl(1, rawdataDown$last)),] # delete last data point of the offending periods
rawdataDown$last <- NULL #delete the unnecessary 'last' column
rawdataDown$time = seq(0, (as.numeric(as.character(experiment$duration))*1000)-50, by=50) # fix the mangled time column
row.names(rawdataDown) <- 1:nrow(rawdataDown) #fix rownames, too
}
View(rawdataDown)
View(rawdata)
View(rawdataDown)
rawdata=rawdataDown
rightOMperiods=which(grepl("optomotorR", sequence$type)) #collect the right turning OM periods
rightOMdata<-filter(rawdata, rawdata$period %in% rightOMperiods) #extract only right turning arena periods
rightOMdata <- rightOMdata %>% select(-c(a_pos)) #drop unnecessary columns
leftOMdata$time=ave(leftOMdata$period, leftOMdata$period, FUN=seq_along) #match the time values to start at each period start
leftOMdata$time=((leftOMdata$time)*50)+max(rightOMdata$time) #make 20Hz data into ms time scale, starting after right turning data
leftOMdata$period=as.factor(leftOMdata$period)
ggplot(data = leftOMdata, aes(x=time, y=fly)) +
geom_line(aes(group=period, colour=period), size=1) +
geom_smooth(method="loess", span = 0.1) +
ylab("Optomotor Resoponse [rel. units]")+
xlab("Time [ms]") +
ggtitle(paste("Left (counter-clockwise) arena rotations -", flyname))
rightOMdata$time=ave(rightOMdata$period, rightOMdata$period, FUN=seq_along) #match the time values to start at each period start
rightOMdata$time=(rightOMdata$time-1)*50 #make 20Hz data into ms time scale
rightOMdata$period=as.factor(rightOMdata$period)
ggplot(data = rightOMdata, aes(x=time, y=fly)) +
geom_line(aes(group=period, colour=period), size=1) +
geom_smooth(method="loess", span = 0.1) +
ylab("Optomotor Resoponse [rel. units]")+
xlab("Time [ms]") +
ggtitle(paste("Right (clockwise) arena rotations -", flyname))
leftOMperiods=which(grepl("optomotorL", sequence$type)) #collect the left turning OM periods
leftOMdata<-filter(rawdata, rawdata$period %in% leftOMperiods)  #extract only left turning arena periods
leftOMdata <- leftOMdata %>% select(-c(a_pos))  #drop unnecessary columns
leftOMdata$time=ave(leftOMdata$period, leftOMdata$period, FUN=seq_along) #match the time values to start at each period start
leftOMdata$time=((leftOMdata$time)*50)+max(rightOMdata$time) #make 20Hz data into ms time scale, starting after right turning data
leftOMdata$period=as.factor(leftOMdata$period)
ggplot(data = leftOMdata, aes(x=time, y=fly)) +
geom_line(aes(group=period, colour=period), size=1) +
geom_smooth(method="loess", span = 0.1) +
ylab("Optomotor Resoponse [rel. units]")+
xlab("Time [ms]") +
ggtitle(paste("Left (counter-clockwise) arena rotations -", flyname))
tempOMdata=rbind(rightOMdata,leftOMdata) #combine left and right OMdata in one dataframe
tempOMdata=aggregate(tempOMdata$fly,FUN=mean,by=list(tempOMdata$time)) #average across periods
colnames(tempOMdata) <- c("time", as.character(flyname)) #set dataframe names
ggplot(data=OMdata, aes(x=OMdata$time, y=OMdata[[as.character(flyname)]])) +
geom_line() +
ylab("Optomotor Resoponse [rel. units]")+
xlab("Time [ms]")
OMdata=tempOMdata
ggplot(data=OMdata, aes(x=OMdata$time, y=OMdata[[as.character(flyname)]])) +
geom_line() +
ylab("Optomotor Resoponse [rel. units]")+
xlab("Time [ms]")
OMmidpoint = OMdata$time[nrow(OMdata)]/2
#right turning traces
x1=OMdata$time[OMdata$time<=OMmidpoint]                     #time
y=OMdata[[as.character(flyname)]][OMdata$time<=OMmidpoint]  #mean right OM response normalized to positive values
xy <-sortedXyData(x1,y)                                     #create sortedXYdata object
LinMod = lm(x1 ~ y, data = xy)
summary(LinMod)
LinMod = lm(y ~ x1, data = xy)
summary(LinMod)
plot(xy)
abline(LinMod)
LinMod$coefficients[2]
load("B:/GitHub/DTSevaluations/example data/t-learn/evaluations/.RData")
LinMod = lm(y ~ x1, data = xy)
LinMod$coefficients[2]
x1=OMdata$time[OMdata$time<=OMmidpoint]                     #time
y=OMdata[[as.character(flyname)]][OMdata$time<=OMmidpoint]  #mean right OM response normalized to positive values
xy <-sortedXyData(x1,y)                                     #create sortedXYdata object
LinMod = lm(y ~ x1, data = xy)
LinMod$coefficients[2]
load("B:/GitHub/DTSevaluations/example data/t-learn/evaluations/.RData")
OMmidpoint = OMdata$time[nrow(OMdata)]/2
OMdata=tempOMdata
OMmidpoint = OMdata$time[nrow(OMdata)]/2
#right turning traces
x1=OMdata$time[OMdata$time<=OMmidpoint]                     #time
y=OMdata[[as.character(flyname)]][OMdata$time<=OMmidpoint]  #mean right OM response normalized to positive values
xy <-sortedXyData(x1,y)                                     #create sortedXYdata object
LinMod = lm(y ~ x1, data = xy)
LinMod$coefficients[2]
mean(x1)
plot(xy)
mean(xy$x)
as.numeric(mean(xy$x))
mean(y)
View(plotOMparams)
View(plotOMparams)
load("B:/GitHub/DTSevaluations/example data/OM_joystick/evaluations/.RData")
View(tempOMparams)
View(tempOMparams)
load("B:/GitHub/DTSevaluations/example data/t-learn/evaluations/.RData")
View(plotOMparams)
View(plotOMparams)
load("B:/GitHub/DTSevaluations/.RData")
View(plotOMparams)
View(plotOMparams)
setwd("B:/GitHub/DTSevaluations")
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
setwd("B:/GitHub/DTSevaluations")
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
setwd("B:/GitHub/DTSevaluations")
source('B:/GitHub/DTSevaluations/HTML_DTS_project.R', echo=TRUE)
