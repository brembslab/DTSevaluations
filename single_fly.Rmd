---
title: "Single Fly Descriptive Data Evaluation Sheet"
output: 
  html_document:
    number_sections: true
    toc: true
    toc_float: true
---
<style type="text/css">
  body .main-container {
    max-width: 1800px !important;
  }
  h1.title {
  font-size: 38px;
  color: DarkRed;
  text-align: center;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, packages, eval=FALSE, echo=FALSE}
# load packages 
library(ggplot2)
library(tidyr)
library(dygraphs)
library(grid)
library(reshape2)
library(dplyr)
library(gridExtra)
library(yaml)
library(ggsignif)
library(effsize)
library(pwr)
library(BayesFactor)
library(genefilter)  # if not available for newest version: setRepositories(addURLs = c(CRANxtras = "http://www.stats.ox.ac.uk/pub/RWin"))
library(seewave)
library(zoo)

## source the script with the functions needed for analysis
source("readXMLdatafile.R")
source("DTS_plotfunctions.R")
```

<center><h2>for time series experiment `r paste(flyname)`</h2></center>
<center>Rendered on `r format(Sys.time(), '%d %B %Y')`</center>

# Metadata

**Date and time of the experiment:** `r format(as.POSIXct(gsub("T", " ", experiment$dateTime)),'%A, %B %d, %Y %H:%M:%S')`  
**Raw data file (XML):** `r paste('<a href="../', basename(xml_name), '">', flyname, '</a>', sep = "")`  
**Experimenter:** `r paste(experimenter$firstname, experimenter$lastname, sep = " ")`; **ORCID:** [`r paste(experimenter$orcid)`](http://orcid.org/`r paste(experimenter$orcid)`)  
**Experiment description:** `r paste(experiment$description)`  
**Experiment duration:** `r paste(experiment$duration)`s  
**Arena type:** `r paste(experiment$arena_type)`; **Measurement device:** `r paste(experiment$meter_type)`  
**Fly description:** `r paste(fly$description)`; **FlyBase ID:** [`r paste(fly$flybase)`](http://flybase.org/reports/`r paste(fly$flybase)`)  
**Sampling rate:** `r paste(experiment$sample_rate)`Hz
```{r sr_condition, echo=FALSE}
sampleratecondition <- round(real_sample_rate)>20
```

```{r samplerate, eval=sampleratecondition, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, comment=NA, results = 'asis'}
cat("<b>Actual samplingrate: </b>", paste(signif(real_sample_rate,4)), " Hz; <b>Downsampled sampling rate (target 20 Hz):</b> ", paste(signif(down_sample_rate,4)), " Hz")
```

# Experimental Design
```{r expdesign, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 3, fig.width = (NofPeriods+1)}
    #plot table of period sequence
    periods=t(sequence)
    colnames(periods)<-sprintf("Period %s",1:NofPeriods)
    grid.table(periods)
```

# Time Traces
## Interactive Time Traces

```{r dytracesraw, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 4, fig.width = 12}    
    
    ##dyplot traces
    dytraces(traces)

```

## Interactive Time Traces (Downsampled data)

```{r dytracesdown, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 4, fig.width = 12}    
    
    ##dyplot traces
    dytraces(rawdata)

```

## Time Traces by Period (20Hz)

```{r PeriodTraces, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 10}

#add columns for PIs and categories to sequence data
sequence$lambda <- NA
sequence$category <- NA

for(i in 1:NofPeriods){
  
  #save colors for later plotting
  if(sequence$outcome[i]==0){
    sequence$color[i]="lightyellow"
    sequence$histocolor[i]="darkgreen"
  } else {
    sequence$color[i]="orange"
    sequence$histocolor[i]="orange"
  }
  if(sequence$outcome[i]==0){
    sequence$color[i]="lightyellow"
    sequence$histocolor[i]="darkgreen"
  } else {
    sequence$color[i]="orange"
    sequence$histocolor[i]="orange"
  }
  if(sequence$contingency[i]==""){
    sequence$color[i]=NA
    sequence$histocolor[i]="red"
    sequence$category[i]=NA
 }
  if(sequence$contingency[i]!=""){
    sequence$category[i] <- paste(sequence$pattern[i],sequence$contingency[i])
  } 
  
    #add training/test to the graphs
  if(sequence$outcome[i]==0){
    training[i] =  "Test"
  } else {
    training[i] =  "Training"
  }
  ###divide raw data into period chunks and prepare period data for later use in group evaluations
      temp  <- rawdata[rawdata$period == i, ]
      keeps = c("a_pos","fly")
      
      if((sequence$type[i]=="yt"||sequence$type[i]=="sw") & sequence$contingency[i]=="right_torque")   #inverse torque data for group histograms
      {
        temp_inv = temp
        temp_inv$fly = -temp_inv$fly # invert the torque values
        period.data[[i]] <- temp_inv[keeps] #list only arena position and fly behavior data by period
      } else if((sequence$type[i]=="fs"||sequence$type[i]=="color") & sequence$contingency[i]=="2_4_Q") #shift position data for group histograms
      {
        temp_shifted = temp
        temp_shifted$a_pos = temp_shifted$a_pos + 900 #shift the position values by 90째
        temp_shifted$a_pos[temp_shifted$a_pos>1796] = temp_shifted$a_pos[temp_shifted$a_pos>1796]-3600 #wrap the shifted 90째 back around to -90째..-180째
        period.data[[i]] <- temp_shifted[keeps] #list only arena position and fly behavior data by period
      } else period.data[[i]] <- temp[keeps] #keep only arena position and fly behavior data by period
      
      if(sequence$type[i]=="fs"||sequence$type[i]=="yt"||sequence$type[i]=="color"||sequence$type[i]=="optomotorR"||sequence$type[i]=="optomotorL")
      {
        ## plot the fly behavior and arena position time traces
        fly_pos_traces(temp)
      }

      ####Calculate period histograms####
      
      #fly behavior
        if(sequence$contingency[i]=="left_torque"){         #shade left torque area
          flyhistos[[i]] <- ggplot(data=temp, aes_string(temp$fly)) +
                    geom_rect(aes(xmin = -Inf, xmax = 0, ymin = -Inf, ymax = Inf), fill=("lightgrey")) +
                    geom_vline(xintercept=0, linetype="dotted") +
                    geom_histogram(binwidth = 3, fill = sequence$histocolor[i]) +
                    labs(x=paste(FlyBehavior, "[arb units]"), y="frequency") +
                    theme_light() +
                    theme(panel.grid.major = element_blank(),
                          panel.grid.minor = element_blank()) +
                    xlim(maxfly) +
                    scale_y_continuous(expand = c(0,0)) +
                    ggtitle(paste(flyname, "Period", i))
        } else if(sequence$contingency[i]=="right_torque"){  #shade right torque area
          flyhistos[[i]] <- ggplot(data=temp, aes_string(temp$fly)) +
                    geom_rect(aes(xmin = 0, xmax = Inf, ymin = -Inf, ymax = Inf), fill=("lightgrey")) +
                    geom_vline(xintercept=0, linetype="dotted") +
                    geom_histogram(binwidth = 3, fill = sequence$histocolor[i]) +
                    labs(x=paste(FlyBehavior, "[arb units]"), y="frequency") +
                    theme_light() +
                    theme(panel.grid.major = element_blank(),
                          panel.grid.minor = element_blank()) +
                    xlim(maxfly) +
                    scale_y_continuous(expand = c(0,0)) +
                    ggtitle(paste(flyname, "Period", i))
        } else {                                            #no shading
          flyhistos[[i]] <- ggplot(data=temp, aes_string(temp$fly)) +
                    geom_vline(xintercept=0, linetype="dotted") +
                    geom_histogram(binwidth = 3, fill = sequence$histocolor[i]) +
                    labs(x=paste(FlyBehavior, "[arb units]"), y="frequency") +
                    theme_light() +
                    theme(panel.grid.major = element_blank(),
                          panel.grid.minor = element_blank()) +
                    xlim(maxfly) +
                    scale_y_continuous(expand = c(0,0)) +
                    ggtitle(paste(flyname, "Period", i))
        }

          
      #arena position
      if(sequence$type[i]=="fs"||sequence$type[i]=="color")
      {
        if(sequence$contingency[i]=="1_3_Q"){  #shade first and third quadrant
          poshistos[[i]] <- ggplot(data=temp, aes_string(temp$a_pos)) +
                    geom_rect(aes(xmin = -Inf, xmax = -1350, ymin = -Inf, ymax = Inf), fill=("lightgrey")) +
                    geom_rect(aes(xmin = -450, xmax = 450, ymin = -Inf, ymax = Inf), fill=("lightgrey")) +
                    geom_rect(aes(xmin = 1350, xmax = Inf, ymin = -Inf, ymax = Inf), fill=("lightgrey")) +
                    geom_vline(xintercept=c(-900,0,900), linetype="dotted") +
                    geom_histogram(binwidth=20, fill = sequence$histocolor[i]) +
                    labs(x="Arena Position [degrees*10]", y="frequency") +
                    theme_light() +
                    theme(panel.grid.major = element_blank(),
                          panel.grid.minor = element_blank()) +
                    scale_x_continuous(breaks = c(-1800, -900, 0, 900, 1800), limits = c(-1800,1800), expand = c(0,0)) +
                    scale_y_continuous(expand = c(0,0)) +
                    ggtitle(paste(flyname, "Period", i))
        } else {                                #shade second and fourth quadrant
                poshistos[[i]] <- ggplot(data=temp, aes_string(temp$a_pos)) +
                    geom_rect(aes(xmin = -1350, xmax = -450, ymin = -Inf, ymax = Inf), fill=("lightgrey")) +
                    geom_rect(aes(xmin = 450, xmax = 1350, ymin = -Inf, ymax = Inf), fill=("lightgrey")) +
                    geom_vline(xintercept=c(-900,0,900), linetype="dotted") +
                    geom_histogram(binwidth=20, fill = sequence$histocolor[i]) +
                    labs(x="Arena Position [degrees*10]", y="frequency") +
                    theme_light() +
                    theme(panel.grid.major = element_blank(),
                          panel.grid.minor = element_blank()) +
                    scale_x_continuous(breaks = c(-1800, -900, 0, 900, 1800), limits = c(-1800,1800), expand = c(0,0)) +
                    scale_y_continuous(expand = c(0,0)) +
                    ggtitle(paste(flyname, "Period", i))
        }
      }
      
      
      ##calculate PIs and 
      ##create data.frame for adding PIs if it doesn't exist, yet
      if(!exists("PIprofile")){PIprofile <- data.frame(matrix(ncol = NofPeriods))}
      if(sequence$type[i]=="fs"||sequence$type[i]=="color") #for arena position
      {
        t1 = sum(abs(temp$a_pos) >= 450 & abs(temp$a_pos) <= 1350)
        t2 = nrow(temp)-t1
        sequence$lambda[i] = (t1-t2)/(t1+t2)
        if (sequence$contingency[i] == '2_4_Q'){sequence$lambda[i]=-sequence$lambda[i]}
        if(l==1){PIprofile[1,i]=sequence$lambda[i]}
      } else if (sequence$type[i]=="yt" || sequence$type[i]=="sw_blue" || sequence$type[i]=="sw_green") #calculate torque PIs
      {
        t2 = table(sign(temp$fly))[1]
        t1 = nrow(temp)-t2
        sequence$lambda[i] = (t1-t2)/(t1+t2)
        if (sequence$contingency[i] == 'right_torque'){sequence$lambda[i]=-sequence$lambda[i]}
        if(l==1){PIprofile[1,i]=sequence$lambda[i]}
      }
      
      ##add categories to separate dataframe
      if(!exists("Categories")){Categories <- data.frame(matrix(ncol = NofPeriods))} #create it, if it doesn't exist, yet and...
      if(l==1){Categories[1,i]=sequence$category[i]} #...add category variable to dataframe
      
    } #for Number of Periods
```

# Histograms
## Fly Behavior Histograms

```{r FlyHistogram, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 12, fig.width = 8}    
    
    ## plot position and fly histograms ##
    # add fly behavior pooled histogram
    flyhistos[[NofPeriods+1]] <- ggplot(data=rawdata, aes_string(rawdata$fly)) + 
      geom_histogram(binwidth=3) + 
      labs(x=paste(FlyBehavior, "[arb units]"), y="frequency") + 
      xlim(-maxfly) +
      ggtitle(paste(flyname, "total"))
    
    ##write histograms
    #fly behavior
    multiplot(plotlist = flyhistos, cols=round(NofPeriods/5))
```

```{r PositionHistogram, eval=('fs' %in% sequence$type || 'color' %in% sequence$type), echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 12, fig.width = 8, comment=NA, results='asis'}    
      cat("\n## Arena Position Histograms\n")
    # add pooled position histogram
      poshistos[[NofPeriods+1]] <- ggplot(data=rawdata, aes_string(rawdata$a_pos)) + 
      geom_vline(xintercept=c(-900,0,900), linetype="dotted") +
      geom_histogram(binwidth=10) +
      labs(x="position [degrees*10]", y="frequency") + 
      scale_x_continuous(breaks = c(-1800, -900, 0, 900, 1800), limits = c(-1800,1800), expand = c(0,0)) +
      scale_y_continuous(expand = c(0,0)) +
      ggtitle(paste(flyname, "total"))
    
   ##write positioon histograms
      multiplot(plotlist = Filter(Negate(is.null), poshistos), cols=round(sum(poshistos!="NULL")/5)) #only print position histograms if there are any

```

<!-- Evaluate optomotor data if they are present -->

```{r om, echo=FALSE}
om <- any(grepl("optomotor", sequence$type)==TRUE)    ###determine if there are optomotor periods
if (om & any(!grepl("optomotor", sequence$type)==TRUE)){   ###if there are non-optomotor periods...
  if (grepl("optomotor", sequence$type[1]) & grepl("optomotor", tail(sequence$type, 1))){ ###...and the optomotor periods are in the beginning and the end
    beforeafter = TRUE
    om = FALSE
  } else {beforeafter = FALSE}
}  else {beforeafter = FALSE}
```

`r if (om | beforeafter) '# Optomotor evaluations'`
`r if (om | beforeafter) '## Optomotor traces (right/left)'`

```{r OptomotorTraces, eval=om, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8, comment=NA, results='asis'}    

####### Do not separate optomotor traces at all ##########

### extract optomotor traces and generate dataframe for right (clockwise) turning arena
OMperiods = which(grepl("optomotorR", sequence$type))                                     #collect the right turning OM periods
rightOMdata <- generateOMdata(OMperiods)                                                  #call function which assembles optomotor data for the identified periods
omtitle = "Right (clockwise) arena rotations -"                                           #set plot title
plotrawOMtraces(rightOMdata, omtitle)                                                     #call function to pot the OM traces

### extract optomotor traces and generate dataframe for left turning (counter-clockwise) arena
OMperiods = which(grepl("optomotorL", sequence$type))                                     #collect the left turning OM periods
leftOMdata <- generateOMdata(OMperiods)                                                   #call function which assembles optomotor data for the identified periods
leftOMdata$time=leftOMdata$time+max(rightOMdata$time)                                     #make left data start after right data
omtitle = "Left (counter-clockwise) arena rotations -"                                    #set plot title
plotrawOMtraces(leftOMdata, omtitle)                                                      #call function to pot the OM traces

### generate averaged optomotor responses over both rotation directions
tempOMdata=rbind(rightOMdata,leftOMdata)                                                  #combine left and right OMdata in one dataframe
tempOMdata=aggregate(tempOMdata$fly,FUN=mean,by=list(tempOMdata$time))                    #average across periods
colnames(tempOMdata) <- c("time", as.character(flyname))                                  #set dataframe names

if(!exists("OMdata"))
{
  OMdata=tempOMdata
} else {
  OMdata[[as.character(flyname)]]=tempOMdata[[as.character(flyname)]]
}
```

`r if (beforeafter) '### Optomotor traces at start'`

```{r OptomotorTracesBefore, eval=beforeafter, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8, comment=NA, results='asis'}    

######### Separate optomotor evaluations: optomotor raw traces at the start of the experiment ###############

### extract and plot optomotor traces for right (clockwise) turning arena at start of experiment
OMperiods = which(grepl("optomotorR", head(sequence$type)))                               #collect the right turning OM periods in the first half of the experiment
rightOMdataBefore <- generateOMdata(OMperiods)                                            #call function which assembles optomotor data for the identified periods
omtitle = "Right (clockwise) arena rotations -"                                           #set plot title
plotrawOMtraces(rightOMdataBefore, omtitle)                                               #call function to pot the OM traces

### extract optomotor traces and generate dataframe for left turning (counter-clockwise) arena at start of experiment
OMperiods = which(grepl("optomotorL", head(sequence$type)))                               #collect the left turning OM periods in the first half of the experiment
leftOMdataBefore <- generateOMdata(OMperiods)                                             #call function which assembles optomotor data for the identified periods
leftOMdataBefore$time=leftOMdataBefore$time+max(rightOMdataBefore$time)                   #make left data start after right data
omtitle = "Left (counter-clockwise) arena rotations -"                                    #set plot title
plotrawOMtraces(leftOMdataBefore, omtitle)                                                #call function to pot the OM traces

### generate averaged optomotor responses over both rotation directions
tempOMdataBefore=rbind(rightOMdataBefore,leftOMdataBefore)                                #combine left and right OMdata in one dataframe
tempOMdataBefore=aggregate(tempOMdataBefore$fly,FUN=mean,by=list(tempOMdataBefore$time))  #average across periods
colnames(tempOMdataBefore) <- c("time", as.character(flyname))                            #set dataframe names

if(!exists("OMdataBefore"))
{
  OMdataBefore=tempOMdataBefore
} else {
  OMdataBefore[[as.character(flyname)]]=tempOMdataBefore[[as.character(flyname)]]
}
```

`r if (beforeafter) '### Optomotor traces at end'`

```{r OptomotorTracesAfter, eval=beforeafter, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8, comment=NA, results='asis'}    

######### Separate optomotor evaluations: optomotor raw traces at the end of the experiment ###############

### extract optomotor traces and generate dataframe for right (clockwise) turning arena at the end of the experiment
OMperiods = which(grepl("optomotorR", tail(sequence$type, 8)))+NofPeriods-8               #collect the right turning OM periods in the last half of the experiment
rightOMdataAfter <- generateOMdata(OMperiods)                                             #call function which assembles optomotor data for the identified periods
omtitle = "Right (clockwise) arena rotations -"                                           #set plot title
plotrawOMtraces(rightOMdataAfter, omtitle)                                                #call function to pot the OM traces

### extract optomotor traces and generate dataframe for left turning (counter-clockwise) arena at end of experiment
OMperiods = which(grepl("optomotorL", tail(sequence$type, 8)))+NofPeriods-8               #collect the left turning OM periods in the last half of the experiment
leftOMdataAfter <- generateOMdata(OMperiods)                                              #call function which assembles optomotor data for the identified periods
leftOMdataAfter$time=leftOMdataAfter$time+max(rightOMdataAfter$time)                      #make left data start after right data
omtitle = "Left (counter-clockwise) arena rotations -"                                    #set plot title
plotrawOMtraces(leftOMdataAfter, omtitle)                                                 #call function to pot the OM traces

### generate averaged optomotor responses over both rotation directions
tempOMdataAfter=rbind(rightOMdataAfter,leftOMdataAfter)                                   #combine left and right OMdata in one dataframe
tempOMdataAfter=aggregate(tempOMdataAfter$fly,FUN=mean,by=list(tempOMdataAfter$time))     #average across periods
colnames(tempOMdataAfter) <- c("time", as.character(flyname))                             #set dataframe names

if(!exists("OMdataAfter"))
{
  OMdataAfter=tempOMdataAfter
} else {
  OMdataAfter[[as.character(flyname)]]=tempOMdataAfter[[as.character(flyname)]]
}
```

`r if (om | beforeafter) '## Averaged optomotor response'`

```{r OptomotorAverage, eval=om, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8, comment=NA, results='asis'}    

plotaveOMtraces(OMdata)
```

`r if (beforeafter) '### Averaged optomotor response at start'`

```{r OptomotorAverageBefore, eval=beforeafter, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8, comment=NA, results='asis'}    

plotaveOMtraces(OMdataBefore)
```

`r if (beforeafter) '### Averaged optomotor response at end'`

```{r OptomotorAverageAfter, eval=beforeafter, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8, comment=NA, results='asis'}    

plotaveOMtraces(OMdataAfter)
```

`r if (om | beforeafter) '## Further optomotor evaluations'`

```{r moreOptomotor, eval=om, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 8, fig.width = 6, comment=NA, results='asis'}    

####### Do not separate optomotor parameters at all ##########

tempOMparams <- OMparamextract(OMdata) #call fucntion for parameter estimation
kable(tempOMparams)  #plot table with data

###collect all coefficients in dataframe for the group
if(!exists("OMparams"))
{
  OMparams=tempOMparams
} else {
  OMparams[as.character(flyname),]=tempOMparams
}

```

`r if (beforeafter) '### Optomotor parameters at start'`

```{r OMparamsBefore, eval=beforeafter, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8, comment=NA, results='asis'}    

######### Separate optomotor evaluations: optomotor parameters at the start of the experiment ###############

tempOMparamsBefore<-OMparamextract(OMdataBefore) #call fucntion for parameter estimation
kable(tempOMparamsBefore)  #plot table with data

###collect all coefficients in dataframe for the group
if(!exists("OMparamsBefore"))
{
  OMparamsBefore=tempOMparamsBefore
} else {
  OMparamsBefore[as.character(flyname),]=tempOMparamsBefore
}

```

`r if (beforeafter) '### Optomotor parameters at end'`

```{r OMparamsAfter, eval=beforeafter, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8, comment=NA, results='asis'}    

######### Separate optomotor evaluations: optomotor parameters at the end of the experiment ###############

tempOMparamsAfter<-OMparamextract(OMdataAfter) #call fucntion for parameter estimation
kable(tempOMparamsAfter)  #plot table with data

###collect all coefficients in dataframe for the group
if(!exists("OMparamsAfter"))
{
  OMparamsAfter=tempOMparamsAfter
} else {
  OMparamsAfter[as.character(flyname),]=tempOMparamsAfter
}

```


# Power spectrum and spectrogram

```{r spectra, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8}
    meanspec(rawdata$fly, f = down_sample_rate, wl = 600) #plot mean power spectrum for each fly
    title(paste(FlyBehavior, "Powerspectrum", flyname))
    spectro(rawdata$fly, f = down_sample_rate, wl=600) #plot spectrogram for each fly
    title(paste(FlyBehavior, "Spectrogram", flyname))
    speclist[[l]] = as.data.frame(meanspec(rawdata$fly, f = down_sample_rate, wl = 600, plot = FALSE)) #collect each spectrum for later averaging
```


```{r PIs, eval=(!all(is.na(sequence$lambda))), echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8, comment=NA, results='asis'}
cat("\n# Learning and avoidance scores\n")

      barplot(as.vector(na.omit(sequence$lambda)), main = paste("Performance Indices", flyname),
            xlab="Time [periods]",
            ylab="PI [rel. units]",
            space=0,
            col = as.vector(na.omit(sequence$color)))
```

# Dwelling time

```{r dwellingpunished, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 12, fig.width = 8}
punishment = c("punished", "unpunished")


##Create a dataframe to be used for the means##
for(t in 1:length(punishment)){
  dwellmeans[[t]] = data.frame(value=rep(2, NofPeriods), punishment=rep(0,NofPeriods)) #create an empty list at the same length as number of periods, with a set of three prenamed columns
  dwellmeans[[t]]$punishment <-  punishment[[t]] #add punished or unpunished to the punishment column
  dwellmeans[[t]]$period = sprintf("PI%d", 1:NofPeriods) #add periods to the data
}

##read the data for each period## 
for(i in 1:NofPeriods){
  temp  <- rawdata[rawdata$period == i, ] #Saves the data as a temporarily dataframe
  if (sequence$contingency[i] == 'left_torque'){ #depending on what side was punished, the punished/unpunished side need to be sorted accordingly
  dwell$punished = temp[temp["fly"] < 0, ] #sort negative data for punished torque data
  dwell$unpunished = temp[temp["fly"] >= 0, ] #sort positive or equal to zero data for unpunished torque data

  } else {
  dwell$punished = temp[temp["fly"] > 0, ] #sort negative data for punished torque data
  dwell$unpunished = temp[temp["fly"] <= 0, ] #sort positive or equal to zero data for unpunished torque data
  }

##Calculations for dwelling time## 
  for(t in 1:length(punishment)){
    scatterperiod[[t]] <- reshape2::melt(lengths(split(dwell[[t]][[1]], cumsum(c(TRUE, diff(dwell[[t]][[1]]) != 50)))))#Finds cumulative data. reshape2::melt is used as the normal melting function complains about uneven data
    scatterperiod[[t]]$period <- i #Add period to the data
    scatterperiod[[t]]$punishment <- punishment[[t]] #Add punished or unpunished to a column
    scatterperiod[[t]][[1]] <- (scatterperiod[[t]][[1]])*0.05 #Transform each datapoint to seconds by multiplying with 0.05
     scattertemp = do.call(rbind, scatterperiod) #transform the listed scatterperiod to a nonlisted dataframe
     scattertemp$value[scattertemp$punishment == 'punished'] <- (-scattertemp$value) #Transforms the punished data to negative time values. This will be used to plot the punished/unpunished around zero rather than both of them being on the positive side 
     dwell[[t]] = reshape2::melt(table(scatterperiod[[t]]$value)) #count the occurences of each of the different dwelling times and add them to a table
     dwell[[t]][[2]] <- 100-(cumsum(dwell[[t]][[2]]/(sum(dwell[[t]][[2]])))*100) #subtracts the cumulative percentage
     dwell[[t]] <- transform(dwell[[t]], value = c(100, value[-nrow(dwell[[t]])])) #shift data down and replaces top value with 100%
     dwelltemp <- ldply (dwell, data.frame) #transforms the listed dwell data to a dataframe
     dwellmeans[[t]]$value[[i]] = mean(scatterperiod[[t]]$value)

  }
  scattertotal[[i]] = scattertemp #Adds the data to a continuous list
  scattertemp = do.call(rbind, scattertotal) #transforms the listed scattertotal data to a continous dataframe


  #plot the dwelling time
  dwellingplot[[i]] = ggplot() +
    geom_line(data = dwelltemp, aes(x = Var1, y = value, color = .id))+
    geom_point(data = dwelltemp, aes(x = Var1, y = value, color = .id))+
    scale_y_log10( breaks=c(0,10,100))+
    scale_x_log10() +
    ggtitle(paste(flyname, "Period", i)) +
    theme_light() +
    labs(x="time [sec]", y="% events",  color = "Outcome") +
    annotate("text", Inf, Inf, label = training[i], hjust =1.1, vjust = 1)+ 
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
    theme(plot.title = element_text(color="black", size=12, face="bold", hjust = 0.5))
}
multiplot(plotlist = dwellingplot, cols=2)
```

# Scatterplot for dwelling times

```{r scatter, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 6, fig.width = 8}
scatterplot = list()

#The function below is an inverse hyperbolic sine transformation to generate negative logarithmic data. I totally understand it and did just copy it...

asinh_trans <- function(){
  trans_new(name = 'asinh', transform = function(x) asinh(x), 
            inverse = function(x) sinh(x))
}

#plot the scattered data and merge it with the dwelling time
scatterplot <- ggplot(scattertemp, aes(x = factor(period), y = value, fill = punishment)) +
  geom_boxplot() +
  geom_hline(yintercept = 0, colour = "#887000", size = 1.2)+
  geom_point(aes(fill = punishment), size = 2, shape = 21, position = position_jitterdodge())+
  #geom_jitter(aes(fill = punishment), width = 0.2)+
  scale_y_continuous(trans = 'asinh',breaks=c(-100,-50,-10,-1,0,1,10,50,100))+
   #theme_light()+
  ggtitle(paste(flyname))+
labs(x=("Experimental sequence"), y="dwelling time [sec]") +
                    theme_light() +
                    theme(panel.grid.major = element_blank(),
                          panel.grid.minor = element_blank()) 


print(scatterplot)
```

# Alternative dwelling data analysis

```{r dwellingpunishednew, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, fig.align = "center", fig.height = 12, fig.width = 8}

temp  <- rawdata #store the entire data set for the fly
temp$sign <- ifelse(temp$fly < 0, 0, 1) #adds a sign based on the torque data. If temp$fly is equal to 0 - then 0, everything else gets a 1
dwellperiod <- split(temp, temp$period) #splits data into periods


for(i in 1:NofPeriods){
  
  #set a vector to sort the punished/unpunished data
  Punishedvector <- ifelse(dwellperiod[[i]]$sign[1] == 0, 2, 1) 
  Unpunishedvector <- ifelse(dwellperiod[[i]]$sign[1] == 1, 2, 1)
  
  #if punished and unpunished data exist within the same period
  if (length(unique(dwellperiod[[i]]$sign)) == 2) { 

    
    dwellperiod[[i]] = rle(dwellperiod[[i]]$sign)[[1]] #counts the consecutive data
    
    #To avoid using a for loop within a for loop, the punished/unpunished data gets seperated into its own dataframe, respectively.
    #The two folling lines seperates punished/unpunished data and transforms the data into seconds. It also adds the data to a melted table.
    #The punished/unpunished vector simply selects every other data point. As every other is maintained throught
    #the entire duration of the period this can be used to its advantage (1,3,5 = punished, 2,4,6 = unpunished, or 1,3,5 = unpunished, 2,4,6 = punished). 
    #As the period does not always start with the same outcome an individual vector is created to differentiate between these two scenarios.
    dwelldataPunished[[i]]<- reshape2::melt(table(dwellperiod[[i]][seq(Punishedvector, length(dwellperiod[[i]]), 2)]*0.05)) 
    dwelldataUnpunished[[i]] <- reshape2::melt(table(dwellperiod[[i]][seq(Unpunishedvector, length(dwellperiod[[i]]), 2)]*0.05)) 
    
    #subtracts the cumulative percentage
    dwelldataPunished[[i]]$value<- 100-(cumsum(dwelldataPunished[[i]]$value/(sum(dwelldataPunished[[i]]$value)))*100)
    dwelldataUnpunished[[i]]$value<- 100-(cumsum(dwelldataUnpunished[[i]]$value/(sum(dwelldataUnpunished[[i]]$value)))*100)
    
    #shift data down and replaces top value with 100%
    dwelldataPunished[[i]] <- transform(dwelldataPunished[[i]], value = c(100, value[-nrow(dwelldataPunished[[i]])])) 
    dwelldataUnpunished[[i]] <- transform(dwelldataUnpunished[[i]], value = c(100, value[-nrow(dwelldataUnpunished[[i]])]))
    
    #In the case that 100% of the dwelling time is in the punished/unpunished zone, the two following
    #if statements sets either the punished to 100%, or unpunished to 100%
    #if  only punished data exists for the particular period, punished is set to 100% and unpunished to 0%
    #This will generate two single dots on the chart, both of them at either 0% or 100%
  } else if (length(unique(dwellperiod[[i]]$sign)) == 1 && (unique(dwellperiod[[i]]$sign)) == 1) { 
    dwelldataPunished[[i]] = data.frame(Var1=rep(120), value=rep(100))
    dwelldataUnpunished[[i]] = data.frame(Var1=rep(0), value=rep(0))
    
    #if  only unpunished data exists for the particular period, punished is set to 0% and unpunished to 100%
  } else if (length(unique(dwellperiod[[i]]$sign)) == 1 && (unique(dwellperiod[[i]]$sign)) == 0){
    dwelldataPunished[[i]] = data.frame(Var1=rep(0), value=rep(0))
    dwelldataUnpunished[[i]] = data.frame(Var1=rep(120), value=rep(100))
  }
  
  #calculates the mean to be used later
  dwellmeanspunished[[i]] = mean(dwelldataPunished[[i]]$value) 
  dwellmeansunpunished[[i]] = mean(dwelldataUnpunished[[i]]$value) 
  
  #plots the data
  dwellingplot[[i]] = ggplot() +
    geom_line(data = dwelldataPunished[[i]], aes(x = Var1, y = value, color = "blue"))+
    geom_line(data = dwelldataUnpunished[[i]], aes(x = Var1, y = value, color = "red"))+
    geom_point(data = dwelldataPunished[[i]], aes(x = Var1, y = value, color = "blue"))+
    geom_point(data = dwelldataUnpunished[[i]], aes(x = Var1, y = value, color = "red"))+
    scale_y_log10( breaks=c(0,10,100))+
    scale_x_log10() +
    ggtitle(paste(flyname, "Period", i)) +
    theme_light() +
    labs(x="time [sec]", y="% events",  color = "Outcome") +
    annotate("text", Inf, Inf, label = training[i], hjust =1.1, vjust = 1)+ 
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
    labs(color='Outcome') +
    scale_color_manual(values=c("red", "blue"), 
                       name="Experimental\nCondition",
                       labels=c("Punished", "Unpunished"))
  theme(plot.title = element_text(color="black", size=12, face="bold", hjust = 0.5))
  }
  
multiplot(plotlist = dwellingplot, cols=2)
```